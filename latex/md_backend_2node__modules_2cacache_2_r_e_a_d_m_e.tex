\chapter{cacache \texorpdfstring{$<$}{<}a href="{}https\+://npm.\+im/cacache"{} \texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}img src="{}https\+://img.\+shields.\+io/npm/v/cacache.\+svg"{} alt="{}npm version"{}/\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/a\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}a href="{}https\+://npm.\+im/cacache"{} \texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}img src="{}https\+://img.\+shields.\+io/npm/l/cacache.\+svg"{} alt="{}license"{}/\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/a\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}a href="{}https\+://travis-\/ci.\+org/npm/cacache"{} \texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}img src="{}https\+://img.\+shields.\+io/travis/npm/cacache.\+svg"{} alt="{}\+Travis"{}/\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/a\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}a href="{}https\+://ci.\+appveyor.\+com/project/npm/cacache"{} \texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}img src="{}https\+://ci.\+appveyor.\+com/api/projects/status/github/npm/cacache?svg=true"{} alt="{}\+App\+Veyor"{}/\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/a\texorpdfstring{$>$}{>} \texorpdfstring{$<$}{<}a href="{}https\+://coveralls.\+io/github/npm/cacache?branch=latest"{} \texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}img src="{}https\+://coveralls.\+io/repos/github/npm/cacache/badge.\+svg?branch=latest"{} alt="{}\+Coverage Status"{}/\texorpdfstring{$>$}{>}\texorpdfstring{$<$}{<}/a\texorpdfstring{$>$}{>}}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e}{}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e}\index{cacache $<$a href="{}https://npm.im/cacache"{} $>$$<$img src="{}https://img.shields.io/npm/v/cacache.svg"{} alt="{}npm version"{}/$>$$<$/a$>$ $<$a href="{}https://npm.im/cacache"{} $>$$<$img src="{}https://img.shields.io/npm/l/cacache.svg"{} alt="{}license"{}/$>$$<$/a$>$ $<$a href="{}https://travis-\/ci.org/npm/cacache"{} $>$$<$img src="{}https://img.shields.io/travis/npm/cacache.svg"{} alt="{}Travis"{}/$>$$<$/a$>$ $<$a href="{}https://ci.appveyor.com/project/npm/cacache"{} $>$$<$img src="{}https://ci.appveyor.com/api/projects/status/github/npm/cacache?svg=true"{} alt="{}AppVeyor"{}/$>$$<$/a$>$ $<$a href="{}https://coveralls.io/github/npm/cacache?branch=latest"{} $>$$<$img src="{}https://coveralls.io/repos/github/npm/cacache/badge.svg?branch=latest"{} alt="{}Coverage Status"{}/$>$$<$/a$>$@{cacache $<$a href=""https://npm.im/cacache"" $>$$<$img src=""https://img.shields.io/npm/v/cacache.svg"" alt=""npm version""/$>$$<$/a$>$ $<$a href=""https://npm.im/cacache"" $>$$<$img src=""https://img.shields.io/npm/l/cacache.svg"" alt=""license""/$>$$<$/a$>$ $<$a href=""https://travis-\/ci.org/npm/cacache"" $>$$<$img src=""https://img.shields.io/travis/npm/cacache.svg"" alt=""Travis""/$>$$<$/a$>$ $<$a href=""https://ci.appveyor.com/project/npm/cacache"" $>$$<$img src=""https://ci.appveyor.com/api/projects/status/github/npm/cacache?svg=true"" alt=""AppVeyor""/$>$$<$/a$>$ $<$a href=""https://coveralls.io/github/npm/cacache?branch=latest"" $>$$<$img src=""https://coveralls.io/repos/github/npm/cacache/badge.svg?branch=latest"" alt=""Coverage Status""/$>$$<$/a$>$}}
\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md421}%
\Hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md421}%
 \href{https://github.com/npm/cacache}{\texttt{ {\ttfamily cacache}}} is a Node.\+js library for managing local key and content address caches. It\textquotesingle{}s really fast, really good at concurrency, and it will never give you corrupted data, even if cache files get corrupted or manipulated.

On systems that support user and group settings on files, cacache will match the {\ttfamily uid} and {\ttfamily gid} values to the folder where the cache lives, even when running as {\ttfamily root}.

It was written to be used as \href{https://npm.im}{\texttt{ npm}}\textquotesingle{}s local cache, but can just as easily be used on its own.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md422}{}\doxysection{\texorpdfstring{Install}{Install}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md422}
{\ttfamily \$ npm install -\/-\/save cacache}\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md423}{}\doxysection{\texorpdfstring{Table of Contents}{Table of Contents}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md423}

\begin{DoxyItemize}
\item Example
\item Features
\item Contributing
\item \doxylink{md_backend_2node__modules_2node-addon-api_2_r_e_a_d_m_e_api}{API}
\begin{DoxyItemize}
\item Using localized APIs
\item Reading
\begin{DoxyItemize}
\item \`{}ls\`{}
\item \`{}ls.stream\`{}
\item \`{}get\`{}
\item \`{}get.stream\`{}
\item \`{}get.info\`{}
\item \`{}get.has\+Content\`{}
\end{DoxyItemize}
\item Writing
\begin{DoxyItemize}
\item \`{}put\`{}
\item \`{}put.stream\`{}
\item \`{}rm.all\`{}
\item \`{}rm.entry\`{}
\item \`{}rm.content\`{}
\item \`{}index.compact\`{}
\item \`{}index.insert\`{}
\end{DoxyItemize}
\item Utilities
\begin{DoxyItemize}
\item \`{}clear\+Memoized\`{}
\item \`{}tmp.mkdir\`{}
\item \`{}tmp.with\+Tmp\`{}
\end{DoxyItemize}
\item Integrity
\begin{DoxyItemize}
\item Subresource Integrity
\item \`{}verify\`{}
\item \`{}verify.last\+Run\`{}
\end{DoxyItemize}
\end{DoxyItemize}
\end{DoxyItemize}\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md424}{}\doxysubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md424}

\begin{DoxyCode}{0}
\DoxyCodeLine{const\ cacache\ =\ require('cacache')}
\DoxyCodeLine{const\ fs\ =\ require('fs')}
\DoxyCodeLine{}
\DoxyCodeLine{const\ tarball\ =\ '/path/to/mytar.tgz'}
\DoxyCodeLine{const\ cachePath\ =\ '/tmp/my-\/toy-\/cache'}
\DoxyCodeLine{const\ key\ =\ 'my-\/unique-\/key-\/1234'}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Cache\ it!\ Use\ \`{}cachePath`\ as\ the\ root\ of\ the\ content\ cache}
\DoxyCodeLine{cacache.put(cachePath,\ key,\ '10293801983029384').then(integrity\ =>\ \{}
\DoxyCodeLine{\ \ console.log(`Saved\ content\ to\ \$\{cachePath\}.`)}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{const\ destination\ =\ '/tmp/mytar.tgz'}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Copy\ the\ contents\ out\ of\ the\ cache\ and\ into\ their\ destination!}
\DoxyCodeLine{//\ But\ this\ time,\ use\ stream\ instead!}
\DoxyCodeLine{cacache.get.stream(}
\DoxyCodeLine{\ \ cachePath,\ key}
\DoxyCodeLine{).pipe(}
\DoxyCodeLine{\ \ fs.createWriteStream(destination)}
\DoxyCodeLine{).on('finish',\ ()\ =>\ \{}
\DoxyCodeLine{\ \ console.log('done\ extracting!')}
\DoxyCodeLine{\})}
\DoxyCodeLine{}
\DoxyCodeLine{//\ The\ same\ thing,\ but\ skip\ the\ key\ index.}
\DoxyCodeLine{cacache.get.byDigest(cachePath,\ integrityHash).then(data\ =>\ \{}
\DoxyCodeLine{\ \ fs.writeFile(destination,\ data,\ err\ =>\ \{}
\DoxyCodeLine{\ \ \ \ console.log('tarball\ data\ fetched\ based\ on\ its\ sha512sum\ and\ written\ out!')}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md425}{}\doxysubsection{\texorpdfstring{Features}{Features}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md425}

\begin{DoxyItemize}
\item Extraction by key or by content address (shasum, etc)
\item Subresource Integrity web standard support
\item Multi-\/hash support -\/ safely host sha1, sha512, etc, in a single cache
\item Automatic content deduplication
\item Fault tolerance (immune to corruption, partial writes, process races, etc)
\item Consistency guarantees on read and write (full data verification)
\item Lockless, high-\/concurrency cache access
\item Streaming support
\item Promise support
\item Fast -- sub-\/millisecond reads and writes including verification
\item Arbitrary metadata storage
\item Garbage collection and additional offline verification
\item Thorough test coverage
\item There\textquotesingle{}s probably a bloom filter in there somewhere. Those are cool, right? 🤔
\end{DoxyItemize}\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md426}{}\doxysubsection{\texorpdfstring{Contributing}{Contributing}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md426}
The cacache team enthusiastically welcomes contributions and project participation! There\textquotesingle{}s a bunch of things you can do if you want to contribute! The \doxylink{readable-stream_2_c_o_n_t_r_i_b_u_t_i_n_g_8md}{Contributor Guide} has all the information you need for everything from reporting bugs to contributing entire new features. Please don\textquotesingle{}t hesitate to jump in if you\textquotesingle{}d like to, or even ask us questions if something isn\textquotesingle{}t clear.

All participants and maintainers in this project are expected to follow \doxylink{_c_o_d_e___o_f___c_o_n_d_u_c_t_8md}{Code of Conduct}, and just generally be excellent to each other.

Please refer to the \doxylink{which_2_c_h_a_n_g_e_l_o_g_8md}{Changelog} for project history details, too.

Happy hacking!\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md427}{}\doxysubsection{\texorpdfstring{API}{API}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md427}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md428}{}\doxysubsubsection{\texorpdfstring{\label{_ls}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+ls(cache) -\/\texorpdfstring{$>$}{>} Promise\texorpdfstring{$<$}{<}Object\texorpdfstring{$>$}{>}}}{\label{_ls}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+ls(cache) -\/\texorpdfstring{$>$}{>} Promise\texorpdfstring{$<$}{<}Object\texorpdfstring{$>$}{>}}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md428}
Lists info for all entries currently in the cache as a single large object. Each entry in the object will be keyed by the unique index key, with corresponding \`{}get.info\`{} objects as the values.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md429}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md429}

\begin{DoxyCode}{0}
\DoxyCodeLine{cacache.ls(cachePath).then(console.log)}
\DoxyCodeLine{//\ Output}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ 'my-\/thing':\ \{}
\DoxyCodeLine{\ \ \ \ key:\ 'my-\/thing',}
\DoxyCodeLine{\ \ \ \ integrity:\ 'sha512-\/BaSe64/EnCoDED+HAsh=='}
\DoxyCodeLine{\ \ \ \ path:\ '.testcache/content/deadbeef',\ //\ joined\ with\ \`{}cachePath`}
\DoxyCodeLine{\ \ \ \ time:\ 12345698490,}
\DoxyCodeLine{\ \ \ \ size:\ 4023948,}
\DoxyCodeLine{\ \ \ \ metadata:\ \{}
\DoxyCodeLine{\ \ \ \ \ \ name:\ 'blah',}
\DoxyCodeLine{\ \ \ \ \ \ version:\ '1.2.3',}
\DoxyCodeLine{\ \ \ \ \ \ description:\ 'this\ was\ once\ a\ package\ but\ now\ it\ is\ my-\/thing'}
\DoxyCodeLine{\ \ \ \ \}}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ 'other-\/thing':\ \{}
\DoxyCodeLine{\ \ \ \ key:\ 'other-\/thing',}
\DoxyCodeLine{\ \ \ \ integrity:\ 'sha1-\/ANothER+hasH=',}
\DoxyCodeLine{\ \ \ \ path:\ '.testcache/content/bada55',}
\DoxyCodeLine{\ \ \ \ time:\ 11992309289,}
\DoxyCodeLine{\ \ \ \ size:\ 111112}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md430}{}\doxysubsubsection{\texorpdfstring{\label{_ls-stream}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+ls.\+stream(cache) -\/\texorpdfstring{$>$}{>} Readable}}{\label{_ls-stream}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+ls.\+stream(cache) -\/\texorpdfstring{$>$}{>} Readable}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md430}
Lists info for all entries currently in the cache as a single large object.

This works just like \`{}ls\`{}, except \`{}get.info\`{} entries are returned as `\textquotesingle{}data'\`{} events on the returned stream.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md431}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md431}

\begin{DoxyCode}{0}
\DoxyCodeLine{cacache.ls.stream(cachePath).on('data',\ console.log)}
\DoxyCodeLine{//\ Output}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ key:\ 'my-\/thing',}
\DoxyCodeLine{\ \ integrity:\ 'sha512-\/BaSe64HaSh',}
\DoxyCodeLine{\ \ path:\ '.testcache/content/deadbeef',\ //\ joined\ with\ \`{}cachePath`}
\DoxyCodeLine{\ \ time:\ 12345698490,}
\DoxyCodeLine{\ \ size:\ 13423,}
\DoxyCodeLine{\ \ metadata:\ \{}
\DoxyCodeLine{\ \ \ \ name:\ 'blah',}
\DoxyCodeLine{\ \ \ \ version:\ '1.2.3',}
\DoxyCodeLine{\ \ \ \ description:\ 'this\ was\ once\ a\ package\ but\ now\ it\ is\ my-\/thing'}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ key:\ 'other-\/thing',}
\DoxyCodeLine{\ \ integrity:\ 'whirlpool-\/WoWSoMuchSupport',}
\DoxyCodeLine{\ \ path:\ '.testcache/content/bada55',}
\DoxyCodeLine{\ \ time:\ 11992309289,}
\DoxyCodeLine{\ \ size:\ 498023984029}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ ...}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md432}{}\doxysubsubsection{\texorpdfstring{\label{_get-data}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+get(cache, key, \mbox{[}opts\mbox{]}) -\/\texorpdfstring{$>$}{>} Promise(\{data, metadata, integrity\})}}{\label{_get-data}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+get(cache, key, \mbox{[}opts\mbox{]}) -\/\texorpdfstring{$>$}{>} Promise(\{data, metadata, integrity\})}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md432}
Returns an object with the cached data, digest, and metadata identified by {\ttfamily key}. The {\ttfamily data} property of this object will be a {\ttfamily Buffer} instance that presumably holds some data that means something to you. I\textquotesingle{}m sure you know what to do with it! cacache just won\textquotesingle{}t care.

{\ttfamily integrity} is a Subresource Integrity string. That is, a string that can be used to verify {\ttfamily data}, which looks like {\ttfamily \texorpdfstring{$<$}{<}hash-\/algorithm\texorpdfstring{$>$}{>}-\/\texorpdfstring{$<$}{<}base64-\/integrity-\/hash\texorpdfstring{$>$}{>}}.

If there is no content identified by {\ttfamily key}, or if the locally-\/stored data does not pass the validity checksum, the promise will be rejected.

A sub-\/function, {\ttfamily get.\+by\+Digest} may be used for identical behavior, except lookup will happen by integrity hash, bypassing the index entirely. This version of the function {\itshape only} returns {\ttfamily data} itself, without any wrapper.

See\+: options\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md433}{}\doxysubsubsubsection{\texorpdfstring{Note}{Note}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md433}
This function loads the entire cache entry into memory before returning it. If you\textquotesingle{}re dealing with Very Large data, consider using \`{}get.stream\`{} instead.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md434}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md434}

\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Look\ up\ by\ key}
\DoxyCodeLine{cache.get(cachePath,\ 'my-\/thing').then(console.log)}
\DoxyCodeLine{//\ Output:}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ metadata:\ \{}
\DoxyCodeLine{\ \ \ \ thingName:\ 'my'}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ integrity:\ 'sha512-\/BaSe64HaSh',}
\DoxyCodeLine{\ \ data:\ Buffer\#<deadbeef>,}
\DoxyCodeLine{\ \ size:\ 9320}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Look\ up\ by\ digest}
\DoxyCodeLine{cache.get.byDigest(cachePath,\ 'sha512-\/BaSe64HaSh').then(console.log)}
\DoxyCodeLine{//\ Output:}
\DoxyCodeLine{Buffer\#<deadbeef>}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md435}{}\doxysubsubsection{\texorpdfstring{\label{_get-stream}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+get.\+stream(cache, key, \mbox{[}opts\mbox{]}) -\/\texorpdfstring{$>$}{>} Readable}}{\label{_get-stream}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+get.\+stream(cache, key, \mbox{[}opts\mbox{]}) -\/\texorpdfstring{$>$}{>} Readable}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md435}
Returns a \href{https://nodejs.org/api/stream.html\#stream_readable_streams}{\texttt{ Readable Stream}} of the cached data identified by {\ttfamily key}.

If there is no content identified by {\ttfamily key}, or if the locally-\/stored data does not pass the validity checksum, an error will be emitted.

{\ttfamily metadata} and {\ttfamily integrity} events will be emitted before the stream closes, if you need to collect that extra data about the cached entry.

A sub-\/function, {\ttfamily get.\+stream.\+by\+Digest} may be used for identical behavior, except lookup will happen by integrity hash, bypassing the index entirely. This version does not emit the {\ttfamily metadata} and {\ttfamily integrity} events at all.

See\+: options\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md436}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md436}

\begin{DoxyCode}{0}
\DoxyCodeLine{//\ Look\ up\ by\ key}
\DoxyCodeLine{cache.get.stream(}
\DoxyCodeLine{\ \ cachePath,\ 'my-\/thing'}
\DoxyCodeLine{).on('metadata',\ metadata\ =>\ \{}
\DoxyCodeLine{\ \ console.log('metadata:',\ metadata)}
\DoxyCodeLine{\}).on('integrity',\ integrity\ =>\ \{}
\DoxyCodeLine{\ \ console.log('integrity:',\ integrity)}
\DoxyCodeLine{\}).pipe(}
\DoxyCodeLine{\ \ fs.createWriteStream('./x.tgz')}
\DoxyCodeLine{)}
\DoxyCodeLine{//\ Outputs:}
\DoxyCodeLine{metadata:\ \{\ ...\ \}}
\DoxyCodeLine{integrity:\ 'sha512-\/SoMeDIGest+64=='}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Look\ up\ by\ digest}
\DoxyCodeLine{cache.get.stream.byDigest(}
\DoxyCodeLine{\ \ cachePath,\ 'sha512-\/SoMeDIGest+64=='}
\DoxyCodeLine{).pipe(}
\DoxyCodeLine{\ \ fs.createWriteStream('./x.tgz')}
\DoxyCodeLine{)}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md437}{}\doxysubsubsection{\texorpdfstring{\label{_get-info}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+get.\+info(cache, key) -\/\texorpdfstring{$>$}{>} Promise}}{\label{_get-info}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+get.\+info(cache, key) -\/\texorpdfstring{$>$}{>} Promise}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md437}
Looks up {\ttfamily key} in the cache index, returning information about the entry if one exists.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md438}{}\doxysubsubsubsection{\texorpdfstring{Fields}{Fields}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md438}

\begin{DoxyItemize}
\item {\ttfamily key} -\/ Key the entry was looked up under. Matches the {\ttfamily key} argument.
\item {\ttfamily integrity} -\/ Subresource Integrity hash for the content this entry refers to.
\item {\ttfamily path} -\/ Filesystem path where content is stored, joined with {\ttfamily cache} argument.
\item {\ttfamily time} -\/ Timestamp the entry was first added on.
\item {\ttfamily metadata} -\/ User-\/assigned metadata associated with the entry/content.
\end{DoxyItemize}\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md439}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md439}

\begin{DoxyCode}{0}
\DoxyCodeLine{cacache.get.info(cachePath,\ 'my-\/thing').then(console.log)}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Output}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ key:\ 'my-\/thing',}
\DoxyCodeLine{\ \ integrity:\ 'sha256-\/MUSTVERIFY+ALL/THINGS=='}
\DoxyCodeLine{\ \ path:\ '.testcache/content/deadbeef',}
\DoxyCodeLine{\ \ time:\ 12345698490,}
\DoxyCodeLine{\ \ size:\ 849234,}
\DoxyCodeLine{\ \ metadata:\ \{}
\DoxyCodeLine{\ \ \ \ name:\ 'blah',}
\DoxyCodeLine{\ \ \ \ version:\ '1.2.3',}
\DoxyCodeLine{\ \ \ \ description:\ 'this\ was\ once\ a\ package\ but\ now\ it\ is\ my-\/thing'}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{\}}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md440}{}\doxysubsubsection{\texorpdfstring{\label{_get-hasContent}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+get.\+has\+Content(cache, integrity) -\/\texorpdfstring{$>$}{>} Promise}}{\label{_get-hasContent}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+get.\+has\+Content(cache, integrity) -\/\texorpdfstring{$>$}{>} Promise}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md440}
Looks up a Subresource Integrity hash in the cache. If content exists for this {\ttfamily integrity}, it will return an object, with the specific single integrity hash that was found in {\ttfamily sri} key, and the size of the found content as {\ttfamily size}. If no content exists for this integrity, it will return {\ttfamily false}.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md441}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md441}

\begin{DoxyCode}{0}
\DoxyCodeLine{cacache.get.hasContent(cachePath,\ 'sha256-\/MUSTVERIFY+ALL/THINGS==').then(console.log)}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Output}
\DoxyCodeLine{\{}
\DoxyCodeLine{\ \ sri:\ \{}
\DoxyCodeLine{\ \ \ \ source:\ 'sha256-\/MUSTVERIFY+ALL/THINGS==',}
\DoxyCodeLine{\ \ \ \ algorithm:\ 'sha256',}
\DoxyCodeLine{\ \ \ \ digest:\ 'MUSTVERIFY+ALL/THINGS==',}
\DoxyCodeLine{\ \ \ \ options:\ []}
\DoxyCodeLine{\ \ \},}
\DoxyCodeLine{\ \ size:\ 9001}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{cacache.get.hasContent(cachePath,\ 'sha521-\/NOT+IN/CACHE==').then(console.log)}
\DoxyCodeLine{}
\DoxyCodeLine{//\ Output}
\DoxyCodeLine{false}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md442}{}\doxysubsubsubsection{\texorpdfstring{\label{_get-options}%
 Options}{\label{_get-options}%
 Options}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md442}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md443}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily opts.\+integrity}}{{\ttfamily opts.\+integrity}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md443}
If present, the pre-\/calculated digest for the inserted content. If this option is provided and does not match the post-\/insertion digest, insertion will fail with an {\ttfamily EINTEGRITY} error.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md444}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily opts.\+memoize}}{{\ttfamily opts.\+memoize}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md444}
Default\+: null

If explicitly truthy, cacache will read from memory and memoize data on bulk read. If {\ttfamily false}, cacache will read from disk data. Reader functions by default read from in-\/memory cache.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md445}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily opts.\+size}}{{\ttfamily opts.\+size}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md445}
If provided, the data stream will be verified to check that enough data was passed through. If there\textquotesingle{}s more or less data than expected, insertion will fail with an {\ttfamily EBADSIZE} error.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md446}{}\doxysubsubsection{\texorpdfstring{\label{_put-data}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+put(cache, key, data, \mbox{[}opts\mbox{]}) -\/\texorpdfstring{$>$}{>} Promise}}{\label{_put-data}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+put(cache, key, data, \mbox{[}opts\mbox{]}) -\/\texorpdfstring{$>$}{>} Promise}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md446}
Inserts data passed to it into the cache. The returned Promise resolves with a digest (generated according to \`{}opts.algorithms\`{}) after the cache entry has been successfully written.

See\+: options\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md447}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md447}

\begin{DoxyCode}{0}
\DoxyCodeLine{fetch(}
\DoxyCodeLine{\ \ 'https://registry.npmjs.org/cacache/-\//cacache-\/1.0.0.tgz'}
\DoxyCodeLine{).then(data\ =>\ \{}
\DoxyCodeLine{\ \ return\ cacache.put(cachePath,\ 'registry.npmjs.org|cacache@1.0.0',\ data)}
\DoxyCodeLine{\}).then(integrity\ =>\ \{}
\DoxyCodeLine{\ \ console.log('integrity\ hash\ is',\ integrity)}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md448}{}\doxysubsubsection{\texorpdfstring{\label{_put-stream}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+put.\+stream(cache, key, \mbox{[}opts\mbox{]}) -\/\texorpdfstring{$>$}{>} Writable}}{\label{_put-stream}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+put.\+stream(cache, key, \mbox{[}opts\mbox{]}) -\/\texorpdfstring{$>$}{>} Writable}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md448}
Returns a \href{https://nodejs.org/api/stream.html\#stream_writable_streams}{\texttt{ Writable Stream}} that inserts data written to it into the cache. Emits an {\ttfamily integrity} event with the digest of written contents when it succeeds.

See\+: options\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md449}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md449}

\begin{DoxyCode}{0}
\DoxyCodeLine{request.get(}
\DoxyCodeLine{\ \ 'https://registry.npmjs.org/cacache/-\//cacache-\/1.0.0.tgz'}
\DoxyCodeLine{).pipe(}
\DoxyCodeLine{\ \ cacache.put.stream(}
\DoxyCodeLine{\ \ \ \ cachePath,\ 'registry.npmjs.org|cacache@1.0.0'}
\DoxyCodeLine{\ \ ).on('integrity',\ d\ =>\ console.log(`integrity\ digest\ is\ \$\{d\}`))}
\DoxyCodeLine{)}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md450}{}\doxysubsubsubsection{\texorpdfstring{\label{_put-options}%
 Options}{\label{_put-options}%
 Options}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md450}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md451}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily opts.\+metadata}}{{\ttfamily opts.\+metadata}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md451}
Arbitrary metadata to be attached to the inserted key.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md452}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily opts.\+size}}{{\ttfamily opts.\+size}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md452}
If provided, the data stream will be verified to check that enough data was passed through. If there\textquotesingle{}s more or less data than expected, insertion will fail with an {\ttfamily EBADSIZE} error.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md453}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily opts.\+integrity}}{{\ttfamily opts.\+integrity}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md453}
If present, the pre-\/calculated digest for the inserted content. If this option is provided and does not match the post-\/insertion digest, insertion will fail with an {\ttfamily EINTEGRITY} error.

{\ttfamily algorithms} has no effect if this option is present.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md454}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily opts.\+algorithms}}{{\ttfamily opts.\+algorithms}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md454}
Default\+: \mbox{[}\textquotesingle{}sha512\textquotesingle{}\mbox{]}

Hashing algorithms to use when calculating the subresource integrity digest for inserted data. Can use any algorithm listed in {\ttfamily crypto.\+get\+Hashes()} or `\textquotesingle{}omakase'{\ttfamily /}\textquotesingle{}お任せします\textquotesingle{}{\ttfamily to pick a random hash algorithm on each insertion. You may also use any anagram of}\textquotesingle{}modnar\textquotesingle{}\`{} to use this feature.

Currently only supports one algorithm at a time (i.\+e., an array length of exactly {\ttfamily 1}). Has no effect if {\ttfamily opts.\+integrity} is present.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md455}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily opts.\+memoize}}{{\ttfamily opts.\+memoize}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md455}
Default\+: null

If provided, cacache will memoize the given cache insertion in memory, bypassing any filesystem checks for that key or digest in future cache fetches. Nothing will be written to the in-\/memory cache unless this option is explicitly truthy.

If {\ttfamily opts.\+memoize} is an object or a {\ttfamily Map}-\/like (that is, an object with {\ttfamily get} and {\ttfamily set} methods), it will be written to instead of the global memoization cache.

Reading from disk data can be forced by explicitly passing {\ttfamily memoize\+: false} to the reader functions, but their default will be to read from memory.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md456}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily opts.\+tmp\+Prefix}}{{\ttfamily opts.\+tmp\+Prefix}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md456}
Default\+: null

Prefix to append on the temporary directory name inside the cache\textquotesingle{}s tmp dir.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md457}{}\doxysubsubsection{\texorpdfstring{\label{_rm-all}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+rm.\+all(cache) -\/\texorpdfstring{$>$}{>} Promise}}{\label{_rm-all}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+rm.\+all(cache) -\/\texorpdfstring{$>$}{>} Promise}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md457}
Clears the entire cache. Mainly by blowing away the cache directory itself.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md458}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md458}

\begin{DoxyCode}{0}
\DoxyCodeLine{cacache.rm.all(cachePath).then(()\ =>\ \{}
\DoxyCodeLine{\ \ console.log('THE\ APOCALYPSE\ IS\ UPON\ US\ 😱')}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md459}{}\doxysubsubsection{\texorpdfstring{\label{_rm-entry}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+rm.\+entry(cache, key, \mbox{[}opts\mbox{]}) -\/\texorpdfstring{$>$}{>} Promise}}{\label{_rm-entry}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+rm.\+entry(cache, key, \mbox{[}opts\mbox{]}) -\/\texorpdfstring{$>$}{>} Promise}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md459}
Alias\+: {\ttfamily cacache.\+rm}

Removes the index entry for {\ttfamily key}. Content will still be accessible if requested directly by content address (\`{}get.stream.by\+Digest\`{}).

By default, this appends a new entry to the index with an integrity of {\ttfamily null}. If {\ttfamily opts.\+remove\+Fully} is set to {\ttfamily true} then the index file itself will be physically deleted rather than appending a {\ttfamily null}.

To remove the content itself (which might still be used by other entries), use \`{}rm.content\`{}. Or, to safely vacuum any unused content, use \`{}verify\`{}.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md460}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md460}

\begin{DoxyCode}{0}
\DoxyCodeLine{cacache.rm.entry(cachePath,\ 'my-\/thing').then(()\ =>\ \{}
\DoxyCodeLine{\ \ console.log('I\ did\ not\ like\ it\ anyway')}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md461}{}\doxysubsubsection{\texorpdfstring{\label{_rm-content}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+rm.\+content(cache, integrity) -\/\texorpdfstring{$>$}{>} Promise}}{\label{_rm-content}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+rm.\+content(cache, integrity) -\/\texorpdfstring{$>$}{>} Promise}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md461}
Removes the content identified by {\ttfamily integrity}. Any index entries referring to it will not be usable again until the content is re-\/added to the cache with an identical digest.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md462}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md462}

\begin{DoxyCode}{0}
\DoxyCodeLine{cacache.rm.content(cachePath,\ 'sha512-\/SoMeDIGest/IN+BaSE64==').then(()\ =>\ \{}
\DoxyCodeLine{\ \ console.log('data\ for\ my-\/thing\ is\ gone!')}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md463}{}\doxysubsubsection{\texorpdfstring{\label{_index-compact}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+index.\+compact(cache, key, match\+Fn, \mbox{[}opts\mbox{]}) -\/\texorpdfstring{$>$}{>} Promise}}{\label{_index-compact}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+index.\+compact(cache, key, match\+Fn, \mbox{[}opts\mbox{]}) -\/\texorpdfstring{$>$}{>} Promise}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md463}
Uses {\ttfamily match\+Fn}, which must be a synchronous function that accepts two entries and returns a boolean indicating whether or not the two entries match, to deduplicate all entries in the cache for the given {\ttfamily key}.

If {\ttfamily opts.\+validate\+Entry} is provided, it will be called as a function with the only parameter being a single index entry. The function must return a Boolean, if it returns {\ttfamily true} the entry is considered valid and will be kept in the index, if it returns {\ttfamily false} the entry will be removed from the index.

If {\ttfamily opts.\+validate\+Entry} is not provided, however, every entry in the index will be deduplicated and kept until the first {\ttfamily null} integrity is reached, removing all entries that were written before the {\ttfamily null}.

The deduplicated list of entries is both written to the index, replacing the existing content, and returned in the Promise.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md464}{}\doxysubsubsection{\texorpdfstring{\label{_index-insert}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+index.\+insert(cache, key, integrity, opts) -\/\texorpdfstring{$>$}{>} Promise}}{\label{_index-insert}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+index.\+insert(cache, key, integrity, opts) -\/\texorpdfstring{$>$}{>} Promise}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md464}
Writes an index entry to the cache for the given {\ttfamily key} without writing content.

It is assumed if you are using this method, you have already stored the content some other way and you only wish to add a new index to that content. The {\ttfamily metadata} and {\ttfamily size} properties are read from {\ttfamily opts} and used as part of the index entry.

Returns a Promise resolving to the newly added entry.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md465}{}\doxysubsubsection{\texorpdfstring{\label{_clear-memoized}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+clear\+Memoized()}}{\label{_clear-memoized}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+clear\+Memoized()}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md465}
Completely resets the in-\/memory entry cache.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md466}{}\doxysubsubsection{\texorpdfstring{\label{_tmp-mkdir}%
 {\ttfamily \texorpdfstring{$>$}{>} tmp.\+mkdir(cache, opts) -\/\texorpdfstring{$>$}{>} Promise\texorpdfstring{$<$}{<}Path\texorpdfstring{$>$}{>}}}{\label{_tmp-mkdir}%
 {\ttfamily \texorpdfstring{$>$}{>} tmp.\+mkdir(cache, opts) -\/\texorpdfstring{$>$}{>} Promise\texorpdfstring{$<$}{<}Path\texorpdfstring{$>$}{>}}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md466}
Returns a unique temporary directory inside the cache\textquotesingle{}s {\ttfamily tmp} dir. This directory will use the same safe user assignment that all the other stuff use.

Once the directory is made, it\textquotesingle{}s the user\textquotesingle{}s responsibility that all files within are given the appropriate {\ttfamily gid}/{\ttfamily uid} ownership settings to match the rest of the cache. If not, you can ask cacache to do it for you by calling \`{}tmp.fix()\`{}, which will fix all tmp directory permissions.

If you want automatic cleanup of this directory, use \`{}tmp.with\+Tmp()\`{}

See\+: options\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md467}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md467}

\begin{DoxyCode}{0}
\DoxyCodeLine{cacache.tmp.mkdir(cache).then(dir\ =>\ \{}
\DoxyCodeLine{\ \ fs.writeFile(path.join(dir,\ 'blablabla'),\ Buffer\#<1234>,\ ...)}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md468}{}\doxysubsubsection{\texorpdfstring{\label{_tmp-fix}%
 {\ttfamily \texorpdfstring{$>$}{>} tmp.\+fix(cache) -\/\texorpdfstring{$>$}{>} Promise}}{\label{_tmp-fix}%
 {\ttfamily \texorpdfstring{$>$}{>} tmp.\+fix(cache) -\/\texorpdfstring{$>$}{>} Promise}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md468}
Sets the {\ttfamily uid} and {\ttfamily gid} properties on all files and folders within the tmp folder to match the rest of the cache.

Use this after manually writing files into \`{}tmp.mkdir\`{} or \`{}tmp.with\+Tmp\`{}.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md469}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md469}

\begin{DoxyCode}{0}
\DoxyCodeLine{cacache.tmp.mkdir(cache).then(dir\ =>\ \{}
\DoxyCodeLine{\ \ writeFile(path.join(dir,\ 'file'),\ someData).then(()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ //\ make\ sure\ we\ didn't\ just\ put\ a\ root-\/owned\ file\ in\ the\ cache}
\DoxyCodeLine{\ \ \ \ cacache.tmp.fix().then(()\ =>\ \{}
\DoxyCodeLine{\ \ \ \ \ \ //\ all\ uids\ and\ gids\ match\ now}
\DoxyCodeLine{\ \ \ \ \})}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md470}{}\doxysubsubsection{\texorpdfstring{\label{_with-tmp}%
 {\ttfamily \texorpdfstring{$>$}{>} tmp.\+with\+Tmp(cache, opts, cb) -\/\texorpdfstring{$>$}{>} Promise}}{\label{_with-tmp}%
 {\ttfamily \texorpdfstring{$>$}{>} tmp.\+with\+Tmp(cache, opts, cb) -\/\texorpdfstring{$>$}{>} Promise}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md470}
Creates a temporary directory with \`{}tmp.mkdir()\`{} and calls {\ttfamily cb} with it. The created temporary directory will be removed when the return value of {\ttfamily cb()} resolves, the tmp directory will be automatically deleted once that promise completes.

The same caveats apply when it comes to managing permissions for the tmp dir\textquotesingle{}s contents.

See\+: options\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md471}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md471}

\begin{DoxyCode}{0}
\DoxyCodeLine{cacache.tmp.withTmp(cache,\ dir\ =>\ \{}
\DoxyCodeLine{\ \ return\ fs.writeFileAsync(path.join(dir,\ 'blablabla'),\ Buffer\#<1234>,\ ...)}
\DoxyCodeLine{\}).then(()\ =>\ \{}
\DoxyCodeLine{\ \ //\ \`{}dir`\ no\ longer\ exists}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md472}{}\doxysubsubsubsection{\texorpdfstring{\label{_tmp-options}%
 Options}{\label{_tmp-options}%
 Options}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md472}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md473}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily opts.\+tmp\+Prefix}}{{\ttfamily opts.\+tmp\+Prefix}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md473}
Default\+: null

Prefix to append on the temporary directory name inside the cache\textquotesingle{}s tmp dir.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md474}{}\doxysubsubsection{\texorpdfstring{\label{_integrity}%
 Subresource Integrity Digests}{\label{_integrity}%
 Subresource Integrity Digests}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md474}
For content verification and addressing, cacache uses strings following the \href{https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity}{\texttt{ Subresource Integrity spec}}. That is, any time cacache expects an {\ttfamily integrity} argument or option, it should be in the format {\ttfamily \texorpdfstring{$<$}{<}hash\+Algorithm\texorpdfstring{$>$}{>}-\/\texorpdfstring{$<$}{<}base64-\/hash\texorpdfstring{$>$}{>}}.

One deviation from the current spec is that cacache will support any hash algorithms supported by the underlying Node.\+js process. You can use {\ttfamily crypto.\+get\+Hashes()} to see which ones you can use.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md475}{}\doxysubsubsubsection{\texorpdfstring{Generating Digests Yourself}{Generating Digests Yourself}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md475}
If you have an existing content shasum, they are generally formatted as a hexadecimal string (that is, a sha1 would look like\+: {\ttfamily 5f5513f8822fdbe5145af33b64d8d970dcf95c6e}). In order to be compatible with cacache, you\textquotesingle{}ll need to convert this to an equivalent subresource integrity string. For this example, the corresponding hash would be\+: {\ttfamily sha1-\/\+X1\+UT+\+IIv2+\+UUWv\+M7\+ZNj\+Zc\+Nz5\+XG4=}.

If you want to generate an integrity string yourself for existing data, you can use something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{const\ crypto\ =\ require('crypto')}
\DoxyCodeLine{const\ hashAlgorithm\ =\ 'sha512'}
\DoxyCodeLine{const\ data\ =\ 'foobarbaz'}
\DoxyCodeLine{}
\DoxyCodeLine{const\ integrity\ =\ (}
\DoxyCodeLine{\ \ hashAlgorithm\ +}
\DoxyCodeLine{\ \ '-\/'\ +}
\DoxyCodeLine{\ \ crypto.createHash(hashAlgorithm).update(data).digest('base64')}
\DoxyCodeLine{)}

\end{DoxyCode}


You can also use \href{https://npm.im/ssri}{\texttt{ {\ttfamily ssri}}} to have a richer set of functionality around SRI strings, including generation, parsing, and translating from existing hex-\/formatted strings.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md476}{}\doxysubsubsection{\texorpdfstring{\label{_verify}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+verify(cache, opts) -\/\texorpdfstring{$>$}{>} Promise}}{\label{_verify}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+verify(cache, opts) -\/\texorpdfstring{$>$}{>} Promise}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md476}
Checks out and fixes up your cache\+:


\begin{DoxyItemize}
\item Cleans up corrupted or invalid index entries.
\item Custom entry filtering options.
\item Garbage collects any content entries not referenced by the index.
\item Checks integrity for all content entries and removes invalid content.
\item Fixes cache ownership.
\item Removes the {\ttfamily tmp} directory in the cache and all its contents.
\end{DoxyItemize}

When it\textquotesingle{}s done, it\textquotesingle{}ll return an object with various stats about the verification process, including amount of storage reclaimed, number of valid entries, number of entries removed, etc.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md477}{}\doxysubsubsubsection{\texorpdfstring{\label{_verify-options}%
 Options}{\label{_verify-options}%
 Options}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md477}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md478}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily opts.\+concurrency}}{{\ttfamily opts.\+concurrency}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md478}
Default\+: 20

Number of concurrently read files in the filesystem while doing clean up.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md479}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily opts.\+filter}}{{\ttfamily opts.\+filter}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md479}
Receives a formatted entry. Return false to remove it. Note\+: might be called more than once on the same entry.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md480}{}\doxysubsubsubsection{\texorpdfstring{{\ttfamily opts.\+log}}{{\ttfamily opts.\+log}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md480}
Custom logger function\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{log:\ \{\ silly\ ()\ \{\}\ \}}
\DoxyCodeLine{log.silly('verify',\ 'verifying\ cache\ at',\ cache)}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md481}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md481}

\begin{DoxyCode}{0}
\DoxyCodeLine{echo\ somegarbage\ >>\ \$CACHEPATH/content/deadbeef}

\end{DoxyCode}



\begin{DoxyCode}{0}
\DoxyCodeLine{cacache.verify(cachePath).then(stats\ =>\ \{}
\DoxyCodeLine{\ \ //\ deadbeef\ collected,\ because\ of\ invalid\ checksum.}
\DoxyCodeLine{\ \ console.log('cache\ is\ much\ nicer\ now!\ stats:',\ stats)}
\DoxyCodeLine{\})}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md482}{}\doxysubsubsection{\texorpdfstring{\label{_verify-last-run}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+verify.\+last\+Run(cache) -\/\texorpdfstring{$>$}{>} Promise}}{\label{_verify-last-run}%
 {\ttfamily \texorpdfstring{$>$}{>} cacache.\+verify.\+last\+Run(cache) -\/\texorpdfstring{$>$}{>} Promise}}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md482}
Returns a {\ttfamily Date} representing the last time {\ttfamily cacache.\+verify} was run on {\ttfamily cache}.\hypertarget{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md483}{}\doxysubsubsubsection{\texorpdfstring{Example}{Example}}\label{md_backend_2node__modules_2cacache_2_r_e_a_d_m_e_autotoc_md483}

\begin{DoxyCode}{0}
\DoxyCodeLine{cacache.verify(cachePath).then(()\ =>\ \{}
\DoxyCodeLine{\ \ cacache.verify.lastRun(cachePath).then(lastTime\ =>\ \{}
\DoxyCodeLine{\ \ \ \ console.log('cacache.verify\ was\ last\ called\ on'\ +\ lastTime)}
\DoxyCodeLine{\ \ \})}
\DoxyCodeLine{\})}

\end{DoxyCode}
 