\chapter{accepts}
\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e}{}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e}\index{accepts@{accepts}}
\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md56}%
\Hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md56}%
 \href{https://npmjs.org/package/accepts}{\texttt{ }} \href{https://npmjs.org/package/accepts}{\texttt{ }} \href{https://nodejs.org/en/download}{\texttt{ }} \href{https://github.com/jshttp/accepts/actions/workflows/ci.yml}{\texttt{ }} \href{https://coveralls.io/r/jshttp/accepts?branch=master}{\texttt{ }}

Higher level content negotiation based on \href{https://www.npmjs.com/package/negotiator}{\texttt{ negotiator}}. Extracted from \href{https://www.npmjs.com/package/koa}{\texttt{ koa}} for general use.

In addition to negotiator, it allows\+:


\begin{DoxyItemize}
\item Allows types as an array or arguments list, ie `(\mbox{[}\textquotesingle{}text/html', \textquotesingle{}application/json\textquotesingle{}\mbox{]}){\ttfamily  as well as}(\textquotesingle{}text/html\textquotesingle{}, \textquotesingle{}application/json\textquotesingle{}){\ttfamily .}
\item {\ttfamily Allows type shorthands such as}json{\ttfamily .}
\item {\ttfamily Returns}false{\ttfamily when no types match}
\item {\ttfamily Treats non-\/existent headers as}\texorpdfstring{$\ast$}{*}\`{}
\end{DoxyItemize}\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md57}{}\doxysection{\texorpdfstring{Installation}{Installation}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md57}
This is a \href{https://nodejs.org/en/}{\texttt{ Node.\+js}} module available through the \href{https://www.npmjs.com/}{\texttt{ npm registry}}. Installation is done using the \href{https://docs.npmjs.com/getting-started/installing-npm-packages-locally}{\texttt{ {\ttfamily npm install} command}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\$\ npm\ install\ accepts}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md58}{}\doxysection{\texorpdfstring{API}{API}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md58}

\begin{DoxyCode}{0}
\DoxyCodeLine{var\ accepts\ =\ require('accepts')}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md59}{}\doxysubsection{\texorpdfstring{accepts(req)}{accepts(req)}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md59}
Create a new {\ttfamily Accepts} object for the given {\ttfamily req}.\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md60}{}\doxysubsubsection{\texorpdfstring{.charset(charsets)}{.charset(charsets)}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md60}
Return the first accepted charset. If nothing in {\ttfamily charsets} is accepted, then {\ttfamily false} is returned.\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md61}{}\doxysubsubsection{\texorpdfstring{.charsets()}{.charsets()}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md61}
Return the charsets that the request accepts, in the order of the client\textquotesingle{}s preference (most preferred first).\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md62}{}\doxysubsubsection{\texorpdfstring{.encoding(encodings)}{.encoding(encodings)}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md62}
Return the first accepted encoding. If nothing in {\ttfamily encodings} is accepted, then {\ttfamily false} is returned.\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md63}{}\doxysubsubsection{\texorpdfstring{.encodings()}{.encodings()}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md63}
Return the encodings that the request accepts, in the order of the client\textquotesingle{}s preference (most preferred first).\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md64}{}\doxysubsubsection{\texorpdfstring{.language(languages)}{.language(languages)}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md64}
Return the first accepted language. If nothing in {\ttfamily languages} is accepted, then {\ttfamily false} is returned.\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md65}{}\doxysubsubsection{\texorpdfstring{.languages()}{.languages()}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md65}
Return the languages that the request accepts, in the order of the client\textquotesingle{}s preference (most preferred first).\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md66}{}\doxysubsubsection{\texorpdfstring{.type(types)}{.type(types)}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md66}
Return the first accepted type (and it is returned as the same text as what appears in the {\ttfamily types} array). If nothing in {\ttfamily types} is accepted, then {\ttfamily false} is returned.

The {\ttfamily types} array can contain full MIME types or file extensions. Any value that is not a full MIME types is passed to `require(\textquotesingle{}mime-\/types').lookup\`{}.\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md67}{}\doxysubsubsection{\texorpdfstring{.types()}{.types()}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md67}
Return the types that the request accepts, in the order of the client\textquotesingle{}s preference (most preferred first).\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md68}{}\doxysection{\texorpdfstring{Examples}{Examples}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md68}
\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md69}{}\doxysubsection{\texorpdfstring{Simple type negotiation}{Simple type negotiation}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md69}
This simple example shows how to use {\ttfamily accepts} to return a different typed respond body based on what the client wants to accept. The server lists it\textquotesingle{}s preferences in order and will get back the best match between the client and server.


\begin{DoxyCode}{0}
\DoxyCodeLine{var\ accepts\ =\ require('accepts')}
\DoxyCodeLine{var\ http\ =\ require('http')}
\DoxyCodeLine{}
\DoxyCodeLine{function\ app\ (req,\ res)\ \{}
\DoxyCodeLine{\ \ var\ accept\ =\ accepts(req)}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ //\ the\ order\ of\ this\ list\ is\ significant;\ should\ be\ server\ preferred\ order}
\DoxyCodeLine{\ \ switch\ (accept.type(['json',\ 'html']))\ \{}
\DoxyCodeLine{\ \ \ \ case\ 'json':}
\DoxyCodeLine{\ \ \ \ \ \ res.setHeader('Content-\/Type',\ 'application/json')}
\DoxyCodeLine{\ \ \ \ \ \ res.write('\{"{}hello"{}:"{}world!"{}\}')}
\DoxyCodeLine{\ \ \ \ \ \ break}
\DoxyCodeLine{\ \ \ \ case\ 'html':}
\DoxyCodeLine{\ \ \ \ \ \ res.setHeader('Content-\/Type',\ 'text/html')}
\DoxyCodeLine{\ \ \ \ \ \ res.write('<b>hello,\ world!</b>')}
\DoxyCodeLine{\ \ \ \ \ \ break}
\DoxyCodeLine{\ \ \ \ default:}
\DoxyCodeLine{\ \ \ \ \ \ //\ the\ fallback\ is\ text/plain,\ so\ no\ need\ to\ specify\ it\ above}
\DoxyCodeLine{\ \ \ \ \ \ res.setHeader('Content-\/Type',\ 'text/plain')}
\DoxyCodeLine{\ \ \ \ \ \ res.write('hello,\ world!')}
\DoxyCodeLine{\ \ \ \ \ \ break}
\DoxyCodeLine{\ \ \}}
\DoxyCodeLine{}
\DoxyCodeLine{\ \ res.end()}
\DoxyCodeLine{\}}
\DoxyCodeLine{}
\DoxyCodeLine{http.createServer(app).listen(3000)}

\end{DoxyCode}


You can test this out with the c\+URL program\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{curl\ -\/I\ -\/H'Accept:\ text/html'\ http://localhost:3000/}

\end{DoxyCode}
\hypertarget{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md70}{}\doxysection{\texorpdfstring{License}{License}}\label{md_backend_2node__modules_2accepts_2_r_e_a_d_m_e_autotoc_md70}
\mbox{[}MIT\mbox{]}(LICENSE) 