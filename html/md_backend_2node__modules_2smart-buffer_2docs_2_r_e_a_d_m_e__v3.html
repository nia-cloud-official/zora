<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: smart-buffer  &lt;a href=&quot;https://travis-ci.org/JoshGlazebrook/smart-buffer&quot; &gt;&lt;img src=&quot;https://travis-ci.org/JoshGlazebrook/smart-buffer.svg?branch=master&quot; alt=&quot;Build Status&quot;/&gt;&lt;/a&gt;  &lt;a href=&quot;https://coveralls.io/github/JoshGlazebrook/smart-buffer?branch=master&quot; &gt;&lt;img src=&quot;https://coveralls.io/repos/github/JoshGlazebrook/smart-buffer/badge.svg?branch=master&quot; alt=&quot;Coverage Status&quot;/&gt;&lt;/a&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md_backend_2node__modules_2smart-buffer_2docs_2_r_e_a_d_m_e__v3.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">smart-buffer &lt;a href="https://travis-ci.org/JoshGlazebrook/smart-buffer" &gt;&lt;img src="https://travis-ci.org/JoshGlazebrook/smart-buffer.svg?branch=master" alt="Build Status"/&gt;&lt;/a&gt; &lt;a href="https://coveralls.io/github/JoshGlazebrook/smart-buffer?branch=master" &gt;&lt;img src="https://coveralls.io/repos/github/JoshGlazebrook/smart-buffer/badge.svg?branch=master" alt="Coverage Status"/&gt;&lt;/a&gt;</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>smart-buffer is a light Buffer wrapper that takes away the need to keep track of what position to read and write data to and from the underlying Buffer. It also adds null terminating string operations and <b>grows</b> as you add more data.</p>
<p><img src="https://nodei.co/npm/smart-buffer.png?downloads=true&amp;downloadRank=true&amp;stars=true" alt="stats" title="stats" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md3341"></a>
What it's useful for:</h2>
<p>I created smart-buffer because I wanted to simplify the process of using Buffer for building and reading network packets to send over a socket. Rather than having to keep track of which position I need to write a UInt16 to after adding a string of variable length, I simply don't have to.</p>
<p>Key Features:</p><ul>
<li>Proxies all of the Buffer write and read functions.</li>
<li>Keeps track of read and write positions for you.</li>
<li>Grows the internal Buffer as you add data to it.</li>
<li>Useful string operations. (Null terminating strings)</li>
<li>Allows for inserting values at specific points in the internal Buffer.</li>
<li>Built in TypeScript</li>
<li>Type Definitions Provided</li>
</ul>
<p>Requirements:</p><ul>
<li>Node v4.0+ is supported at this time. (Versions prior to 2.0 will work on node 0.10)</li>
</ul>
<h3><a class="anchor" id="autotoc_md3342"></a>
Note:</h3>
<p>smart-buffer can be used for writing to an underlying buffer as well as reading from it. It however does not function correctly if you're mixing both read and write operations with each other.</p>
<h1><a class="anchor" id="autotoc_md3343"></a>
Breaking Changes with 2.0</h1>
<p>The latest version (2.0+) is written in TypeScript, and are compiled to ES6 Javascript. This means the earliest Node.js it supports will be 4.x (in strict mode.) If you're using version 6 and above it will work without any issues. From an API standpoint, 2.0 is backwards compatible. The only difference is SmartBuffer is not exported directly as the root module.</p>
<h1><a class="anchor" id="autotoc_md3344"></a>
Breaking Changes with 3.0</h1>
<p>Starting with 3.0, if any of the readIntXXXX() methods are called and the requested data is larger than the bounds of the internally managed valid buffer data, an exception will now be thrown.</p>
<h1><a class="anchor" id="autotoc_md3345"></a>
Installing:</h1>
<p><code>npm install smart-buffer</code></p>
<p>or</p>
<p><code>yarn add smart-buffer</code></p>
<p>Note: The published NPM package includes the built javascript library. If you cloned this repo and wish to build the library manually use:</p>
<p><code>tsc -p ./</code></p>
<h1><a class="anchor" id="autotoc_md3346"></a>
Using smart-buffer</h1>
<h2><a class="anchor" id="autotoc_md3347"></a>
Example</h2>
<p>Say you were building a packet that had to conform to the following protocol:</p>
<p><code>[PacketType:2][PacketLength:2][Data:XX]</code></p>
<p>To build this packet using the vanilla Buffer class, you would have to count up the length of the data payload beforehand. You would also need to keep track of the current "cursor" position in your Buffer so you write everything in the right places. With smart-buffer you don't have to do either of those things.</p>
<div class="fragment"><div class="line">// 1.x (javascript)</div>
<div class="line">var SmartBuffer = require(&#39;smart-buffer&#39;);</div>
<div class="line"> </div>
<div class="line">// 1.x (typescript)</div>
<div class="line">import SmartBuffer = require(&#39;smart-buffer&#39;);</div>
<div class="line"> </div>
<div class="line">// 2.x+ (javascript)</div>
<div class="line">const SmartBuffer = require(&#39;smart-buffer&#39;).SmartBuffer;</div>
<div class="line"> </div>
<div class="line">// 2.x+ (typescript)</div>
<div class="line">import { SmartBuffer, SmartBufferOptions} from &#39;smart-buffer&#39;;</div>
<div class="line"> </div>
<div class="line">function createLoginPacket(username, password, age, country) {</div>
<div class="line">    let packet = new SmartBuffer();</div>
<div class="line">    packet.writeUInt16LE(0x0060); // Login Packet Type/ID</div>
<div class="line">    packet.writeStringNT(username);</div>
<div class="line">    packet.writeStringNT(password);</div>
<div class="line">    packet.writeUInt8(age);</div>
<div class="line">    packet.writeStringNT(country);</div>
<div class="line">    packet.writeUInt16LE(packet.length - 2, 2);</div>
<div class="line">    </div>
<div class="line">    return packet.toBuffer();</div>
<div class="line">}</div>
</div><!-- fragment --><p> With the above function, you now can do this: </p><div class="fragment"><div class="line">let login = createLoginPacket(&quot;Josh&quot;, &quot;secret123&quot;, 22, &quot;United States&quot;);</div>
<div class="line"> </div>
<div class="line">// &lt;Buffer 60 00 1e 00 4a 6f 73 68 00 73 65 63 72 65 74 31 32 33 00 16 55 6e 69 74 65 64 20 53 74 61 74 65 73 00&gt;</div>
</div><!-- fragment --><p> Notice that the <code>[PacketLength:2]</code> part of the packet was inserted after we had added everything else, and as shown in the Buffer dump above, is in the correct location along with everything else.</p>
<p>Reading back the packet we created above is just as easy: </p><div class="fragment"><div class="line">let reader = SmartBuffer.fromBuffer(login);</div>
<div class="line"> </div>
<div class="line">let logininfo = {</div>
<div class="line">    packetType: reader.readUInt16LE(),</div>
<div class="line">    packetLength: reader.readUInt16LE(),</div>
<div class="line">    username: reader.readStringNT(),</div>
<div class="line">    password: reader.readStringNT(),</div>
<div class="line">    age: reader.readUInt8(),</div>
<div class="line">    country: reader.readStringNT()</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line">{ </div>
<div class="line">    packetType: 96, (0x0060)</div>
<div class="line">    packetLength: 30,</div>
<div class="line">    username: &#39;Josh&#39;,</div>
<div class="line">    password: &#39;secret123&#39;,</div>
<div class="line">    age: 22,</div>
<div class="line">    country: &#39;United States&#39; </div>
<div class="line">};</div>
<div class="line">*/</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md3348"></a>
Api Reference:</h1>
<h3><a class="anchor" id="autotoc_md3349"></a>
Constructing a smart-buffer</h3>
<p>smart-buffer has a few different ways to construct an instance. Starting with version 2.0, the following factory methods are preffered.</p>
<div class="fragment"><div class="line">let SmartBuffer = require(&#39;smart-buffer&#39;);</div>
<div class="line"> </div>
<div class="line">// Creating SmartBuffer from existing Buffer</div>
<div class="line">let buff = SmartBuffer.fromBuffer(buffer); // Creates instance from buffer. (Uses default utf8 encoding)</div>
<div class="line">let buff = SmartBuffer.fromBuffer(buffer, &#39;ascii&#39;); // Creates instance from buffer with ascii encoding for Strings. </div>
<div class="line"> </div>
<div class="line">// Creating SmartBuffer with specified internal Buffer size.</div>
<div class="line">let buff = SmartBuffer.fromSize(1024); // Creates instance with internal Buffer size of 1024.</div>
<div class="line">let buff = SmartBuffer.fromSize(1024, &#39;utf8&#39;); // Creates instance with intenral Buffer size of 1024, and utf8 encoding. </div>
<div class="line"> </div>
<div class="line">// Creating SmartBuffer with options object. This one specifies size and encoding.</div>
<div class="line">let buff = SmartBuffer.fromOptions({</div>
<div class="line">    size: 1024,</div>
<div class="line">    encoding: &#39;ascii&#39;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// Creating SmartBuffer with options object. This one specified an existing Buffer.</div>
<div class="line">let buff = SmartBuffer.fromOptions({</div>
<div class="line">    buff: buffer</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// Just want a regular SmartBuffer with all default options?</div>
<div class="line">let buff = new SmartBuffer();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3350"></a>
Backwards Compatibility:</h2>
<p>All constructors used prior to 2.0 still are supported. However it's not recommended to use these.</p>
<div class="fragment"><div class="line">let writer = new SmartBuffer();               // Defaults to utf8, 4096 length internal Buffer.</div>
<div class="line">let writer = new SmartBuffer(1024);           // Defaults to utf8, 1024 length internal Buffer.</div>
<div class="line">let writer = new SmartBuffer(&#39;ascii&#39;);         // Sets to ascii encoding, 4096 length internal buffer.</div>
<div class="line">let writer = new SmartBuffer(1024, &#39;ascii&#39;);  // Sets to ascii encoding, 1024 length internal buffer.</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3351"></a>
Reading Data</h2>
<p>smart-buffer supports all of the common read functions you will find in the vanilla Buffer class. The only difference is, you do not need to specify which location to start reading from. This is possible because as you read data out of a smart-buffer, it automatically progresses an internal read offset/position to know where to pick up from on the next read.</p>
<h2><a class="anchor" id="autotoc_md3352"></a>
Reading Numeric Values</h2>
<p>When numeric values, you simply need to call the function you want, and the data is returned.</p>
<p>Supported Operations:</p><ul>
<li>readInt8</li>
<li>readInt16BE</li>
<li>readInt16LE</li>
<li>readInt32BE</li>
<li>readInt32LE</li>
<li>readBigInt64LE</li>
<li>readBigInt64BE</li>
<li>readUInt8</li>
<li>readUInt16BE</li>
<li>readUInt16LE</li>
<li>readUInt32BE</li>
<li>readUInt32LE</li>
<li>readBigUInt64LE</li>
<li>readBigUInt64BE</li>
<li>readFloatBE</li>
<li>readFloatLE</li>
<li>readDoubleBE</li>
<li>readDoubleLE</li>
</ul>
<div class="fragment"><div class="line">let reader = new SmartBuffer(somebuffer);</div>
<div class="line">let num = reader.readInt8();</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md3353"></a>
Reading String Values</h2>
<p>When reading String values, you can either choose to read a null terminated string, or a string of a specified length.</p>
<h3><a class="anchor" id="autotoc_md3354"></a>
SmartBuffer.readStringNT( [encoding] )</h3>
<blockquote class="doxtable">
<p>&zwj;<code>String</code> <b>String encoding to use</b> - Defaults to the encoding set in the constructor. </p>
</blockquote>
<p>returns <code>String</code></p>
<blockquote class="doxtable">
<p>&zwj;Note: When readStringNT is called and there is no null character found, smart-buffer will read to the end of the internal Buffer. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md3355"></a>
SmartBuffer.readString( [length] )</h3>
<h3><a class="anchor" id="autotoc_md3356"></a>
SmartBuffer.readString( [encoding] )</h3>
<h3><a class="anchor" id="autotoc_md3357"></a>
SmartBuffer.readString( [length], [encoding] )</h3>
<blockquote class="doxtable">
<p>&zwj;<code>Number</code> <b>Length of the string to read</b> </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<code>String</code> <b>String encoding to use</b> - Defaults to the encoding set in the constructor, or utf8. </p>
</blockquote>
<p>returns <code>String</code></p>
<blockquote class="doxtable">
<p>&zwj;Note: When readString is called without a specified length, smart-buffer will read to the end of the internal Buffer. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md3358"></a>
Reading Buffer Values</h2>
<h3><a class="anchor" id="autotoc_md3359"></a>
SmartBuffer.readBuffer( length )</h3>
<blockquote class="doxtable">
<p>&zwj;<code>Number</code> <b>Length of data to read into a Buffer</b> </p>
</blockquote>
<p>returns <code>Buffer</code></p>
<blockquote class="doxtable">
<p>&zwj;Note: This function uses <code>slice</code> to retrieve the Buffer. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md3360"></a>
SmartBuffer.readBufferNT()</h3>
<p>returns <code>Buffer</code></p>
<blockquote class="doxtable">
<p>&zwj;Note: This reads the next sequence of bytes in the buffer until a null (0x00) value is found. (Null terminated buffer) Note: This function uses <code>slice</code> to retrieve the Buffer. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md3361"></a>
Writing Data</h2>
<p>smart-buffer supports all of the common write functions you will find in the vanilla Buffer class. The only difference is, you do not need to specify which location to write to in your Buffer by default. You do however have the option of <b>inserting</b> a piece of data into your smart-buffer at a given location.</p>
<h2><a class="anchor" id="autotoc_md3362"></a>
Writing Numeric Values</h2>
<p>For numeric values, you simply need to call the function you want, and the data is written at the end of the internal Buffer's current write position. You can specify a offset/position to <b>insert</b> the given value at, but keep in mind this does not override data at the given position. This feature also does not work properly when inserting a value beyond the current internal length of the smart-buffer (length being the .length property of the smart-buffer instance you're writing to)</p>
<p>Supported Operations:</p><ul>
<li>writeInt8</li>
<li>writeInt16BE</li>
<li>writeInt16LE</li>
<li>writeInt32BE</li>
<li>writeInt32LE</li>
<li>writeBigInt64BE</li>
<li>writeBigInt64LE</li>
<li>writeUInt8</li>
<li>writeUInt16BE</li>
<li>writeUInt16LE</li>
<li>writeUInt32BE</li>
<li>writeUInt32LE</li>
<li>writeBigUInt64BE</li>
<li>writeBigUInt64LE</li>
<li>writeFloatBE</li>
<li>writeFloatLE</li>
<li>writeDoubleBE</li>
<li>writeDoubleLE</li>
</ul>
<p>The following signature is the same for all the above functions:</p>
<h3><a class="anchor" id="autotoc_md3363"></a>
SmartBuffer.writeInt8( value, [offset] )</h3>
<blockquote class="doxtable">
<p>&zwj;<code>Number</code> <b>A valid Int8 number</b> </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<code>Number</code> <b>The position to insert this value at</b> </p>
</blockquote>
<p>returns this</p>
<blockquote class="doxtable">
<p>&zwj;Note: All write operations return <code>this</code> to allow for chaining. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md3364"></a>
Writing String Values</h2>
<p>When reading String values, you can either choose to write a null terminated string, or a non null terminated string.</p>
<h3><a class="anchor" id="autotoc_md3365"></a>
SmartBuffer.writeStringNT( value, [offset], [encoding] )</h3>
<h3><a class="anchor" id="autotoc_md3366"></a>
SmartBuffer.writeStringNT( value, [offset] )</h3>
<h3><a class="anchor" id="autotoc_md3367"></a>
SmartBuffer.writeStringNT( value, [encoding] )</h3>
<blockquote class="doxtable">
<p>&zwj;<code>String</code> <b>String value to write</b> </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<code>Number</code> <b>The position to insert this String at</b> </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<code>String</code> <b>The String encoding to use.</b> - Defaults to the encoding set in the constructor, or utf8. </p>
</blockquote>
<p>returns this</p>
<h3><a class="anchor" id="autotoc_md3368"></a>
SmartBuffer.writeString( value, [offset], [encoding] )</h3>
<h3><a class="anchor" id="autotoc_md3369"></a>
SmartBuffer.writeString( value, [offset] )</h3>
<h3><a class="anchor" id="autotoc_md3370"></a>
SmartBuffer.writeString( value, [encoding] )</h3>
<blockquote class="doxtable">
<p>&zwj;<code>String</code> <b>String value to write</b> </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<code>Number</code> <b>The position to insert this String at</b> </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<code>String</code> <b>The String encoding to use</b> - Defaults to the encoding set in the constructor, or utf8. </p>
</blockquote>
<p>returns this</p>
<h2><a class="anchor" id="autotoc_md3371"></a>
Writing Buffer Values</h2>
<h3><a class="anchor" id="autotoc_md3372"></a>
SmartBuffer.writeBuffer( value, [offset] )</h3>
<blockquote class="doxtable">
<p>&zwj;<code>Buffer</code> <b>Buffer value to write</b> </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<code>Number</code> <b>The position to insert this Buffer's content at</b> </p>
</blockquote>
<p>returns this</p>
<h3><a class="anchor" id="autotoc_md3373"></a>
SmartBuffer.writeBufferNT( value, [offset] )</h3>
<blockquote class="doxtable">
<p>&zwj;<code>Buffer</code> <b>Buffer value to write</b> </p>
</blockquote>
<blockquote class="doxtable">
<p>&zwj;<code>Number</code> <b>The position to insert this Buffer's content at</b> </p>
</blockquote>
<p>returns this</p>
<h2><a class="anchor" id="autotoc_md3374"></a>
Utility Functions</h2>
<h3><a class="anchor" id="autotoc_md3375"></a>
SmartBuffer.clear()</h3>
<p>Resets the SmartBuffer to its default state where it can be reused for reading or writing.</p>
<h3><a class="anchor" id="autotoc_md3376"></a>
SmartBuffer.remaining()</h3>
<p>returns <code>Number</code> The amount of data left to read based on the current read Position.</p>
<h3><a class="anchor" id="autotoc_md3377"></a>
SmartBuffer.skip( value )</h3>
<blockquote class="doxtable">
<p>&zwj;<code>Number</code> <b>The amount of bytes to skip ahead</b> </p>
</blockquote>
<p>Skips the read position ahead by the given value.</p>
<p>returns this</p>
<h3><a class="anchor" id="autotoc_md3378"></a>
SmartBuffer.rewind( value )</h3>
<blockquote class="doxtable">
<p>&zwj;<code>Number</code> <b>The amount of bytes to reward backwards</b> </p>
</blockquote>
<p>Rewinds the read position backwards by the given value.</p>
<p>returns this</p>
<h3><a class="anchor" id="autotoc_md3379"></a>
SmartBuffer.moveTo( position )</h3>
<blockquote class="doxtable">
<p>&zwj;<code>Number</code> <b>The point to skip the read position to</b> </p>
</blockquote>
<p>Moves the read position to the given point. returns this</p>
<h3><a class="anchor" id="autotoc_md3380"></a>
SmartBuffer.toBuffer()</h3>
<p>returns <code>Buffer</code> A Buffer containing the contents of the internal Buffer.</p>
<blockquote class="doxtable">
<p>&zwj;Note: This uses the slice function. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md3381"></a>
SmartBuffer.toString( [encoding] )</h3>
<blockquote class="doxtable">
<p>&zwj;<code>String</code> <b>The String encoding to use</b> - Defaults to the encoding set in the constructor, or utf8. </p>
</blockquote>
<p>returns <code>String</code> The internal Buffer in String representation.</p>
<h2><a class="anchor" id="autotoc_md3382"></a>
Properties</h2>
<h3><a class="anchor" id="autotoc_md3383"></a>
SmartBuffer.length</h3>
<p>returns <code>Number</code> <b>The length of the data that is being tracked in the internal Buffer</b> - Does NOT return the absolute length of the internal Buffer being written to.</p>
<h2><a class="anchor" id="autotoc_md3384"></a>
License</h2>
<p>This work is licensed under the <a href="http://en.wikipedia.org/wiki/MIT_License">MIT license</a>. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
