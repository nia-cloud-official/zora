.TH "md_backend_2node__modules_2ansi-regex_2readme" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md_backend_2node__modules_2ansi-regex_2readme \- ansi-regex 
.PP
 
.PP
.RS 4
Regular expression for matching \fRANSI escape codes\fP 
.RE
.PP
.SH "Install"
.PP
.PP
.nf
$ npm install ansi\-regex
.fi
.PP
.SH "Usage"
.PP
.PP
.nf
const ansiRegex = require('ansi\-regex');

ansiRegex()\&.test('\\u001B[4mcake\\u001B[0m');
//=> true

ansiRegex()\&.test('cake');
//=> false

'\\u001B[4mcake\\u001B[0m'\&.match(ansiRegex());
//=> ['\\u001B[4m', '\\u001B[0m']

'\\u001B[4mcake\\u001B[0m'\&.match(ansiRegex({onlyFirst: true}));
//=> ['\\u001B[4m']

'\\u001B]8;;https://github\&.com\\u0007click\\u001B]8;;\\u0007'\&.match(ansiRegex());
//=> ['\\u001B]8;;https://github\&.com\\u0007', '\\u001B]8;;\\u0007']
.fi
.PP
.SH "API"
.PP
.SS "ansiRegex(options?)"
Returns a regex for matching ANSI escape codes\&.
.SS "options"
Type: \fRobject\fP
.SS "onlyFirst"
Type: \fRboolean\fP
.br
 Default: \fRfalse\fP *(Matches any ANSI escape codes in a string)*
.PP
Match only the first ANSI escape\&.
.SH "FAQ"
.PP
.SS "Why do you test for codes not in the ECMA 48 standard?"
Some of the codes we run as a test are codes that we acquired finding various lists of non-standard or manufacturer specific codes\&. We test for both standard and non-standard codes, as most of them follow the same or similar format and can be safely matched in strings without the risk of removing actual string content\&. There are a few non-standard control codes that do not follow the traditional format (i\&.e\&. they end in numbers) thus forcing us to exclude them from the test because we cannot reliably match them\&.
.PP
On the historical side, those ECMA standards were established in the early 90's whereas the VT100, for example, was designed in the mid/late 70's\&. At that point in time, control codes were still pretty ungoverned and engineers used them for a multitude of things, namely to activate hardware ports that may have been proprietary\&. Somewhere else you see a similar 'anarchy' of codes is in the x86 architecture for processors; there are a ton of 'interrupts' that can mean different things on certain brands of processors, most of which have been phased out\&.
.SH "Maintainers"
.PP
.IP "\(bu" 2
\fRSindre Sorhus\fP
.IP "\(bu" 2
\fRJosh Junon\fP
.PP
.PP
.PP
.PP
 \fB \fRGet professional support for this package with a Tidelift subscription\fP \fP 
.br
 \*< Tidelift helps make open source sustainable for maintainers while giving companies
.br
assurances about security, maintenance, and licensing for their dependencies\&. \*>   
