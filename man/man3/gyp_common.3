.TH "gyp.common" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
gyp.common
.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBCycleError\fP"
.br
.ti -1c
.RI "class \fBGypError\fP"
.br
.ti -1c
.RI "class \fBmemoize\fP"
.br
.ti -1c
.RI "class \fBOrderedSet\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBExceptionAppend\fP (e, msg)"
.br
.ti -1c
.RI "\fBFindQualifiedTargets\fP (target, qualified_list)"
.br
.ti -1c
.RI "\fBParseQualifiedTarget\fP (target)"
.br
.ti -1c
.RI "\fBResolveTarget\fP (build_file, target, toolset)"
.br
.ti -1c
.RI "\fBBuildFile\fP (fully_qualified_target)"
.br
.ti -1c
.RI "\fBGetEnvironFallback\fP (var_list, default)"
.br
.ti -1c
.RI "\fBQualifiedTarget\fP (build_file, target, toolset)"
.br
.ti -1c
.RI "\fBRelativePath\fP (path, relative_to, follow_path_symlink=True)"
.br
.ti -1c
.RI "\fBInvertRelativePath\fP (path, toplevel_dir=None)"
.br
.ti -1c
.RI "\fBFixIfRelativePath\fP (path, relative_to)"
.br
.ti -1c
.RI "\fBUnrelativePath\fP (path, relative_to)"
.br
.ti -1c
.RI "\fBEncodePOSIXShellArgument\fP (argument)"
.br
.ti -1c
.RI "\fBEncodePOSIXShellList\fP (list)"
.br
.ti -1c
.RI "\fBDeepDependencyTargets\fP (target_dicts, roots)"
.br
.ti -1c
.RI "\fBBuildFileTargets\fP (target_list, build_file)"
.br
.ti -1c
.RI "\fBAllTargets\fP (target_list, target_dicts, build_file)"
.br
.ti -1c
.RI "\fBWriteOnDiff\fP (filename)"
.br
.ti -1c
.RI "\fBEnsureDirExists\fP (path)"
.br
.ti -1c
.RI "\fBGetFlavor\fP (params)"
.br
.ti -1c
.RI "\fBCopyTool\fP (flavor, out_path, generator_flags={})"
.br
.ti -1c
.RI "\fBuniquer\fP (seq, idfun=lambda x:x)"
.br
.ti -1c
.RI "\fBTopologicallySorted\fP (graph, get_edges)"
.br
.ti -1c
.RI "\fBCrossCompileRequested\fP ()"
.br
.ti -1c
.RI "\fBIsCygwin\fP ()"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fB_quote\fP = re\&.compile('[\\t\\n #$%&'()*;<=>?[{|}~]|^$')"
.br
.ti -1c
.RI "\fB_escape\fP = re\&.compile(r'(['\\\\`])')"
.br
.ti -1c
.RI "\fBtmp_path\fP"
.br
.ti -1c
.RI "\fBtmp_file\fP"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "gyp\&.common\&.AllTargets ( target_list,  target_dicts,  build_file)"

.PP
.nf
Returns all targets (direct and dependencies) for the specified build_file\&.

.fi
.PP
 
.PP
Definition at line \fB328\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.BuildFile ( fully_qualified_target)"

.PP
Definition at line \fB112\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.BuildFileTargets ( target_list,  build_file)"

.PP
.nf
From a target_list, returns the subset from the specified build_file\&.

.fi
.PP
 
.PP
Definition at line \fB322\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.CopyTool ( flavor,  out_path,  generator_flags = \fR{}\fP)"

.PP
.nf
Finds (flock|mac|win)_tool\&.gyp in the gyp directory and copies it
to |out_path|\&.
.fi
.PP
 
.PP
Definition at line \fB461\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.CrossCompileRequested ()"

.PP
Definition at line \fB632\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.DeepDependencyTargets ( target_dicts,  roots)"

.PP
.nf
Returns the recursive list of target dependencies\&.
.fi
.PP
 
.PP
Definition at line \fB303\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.EncodePOSIXShellArgument ( argument)"

.PP
.nf
Encodes |argument| suitably for consumption by POSIX shells\&.

argument may be quoted and escaped as necessary to ensure that POSIX shells
treat the returned value as a literal representing the argument passed to
this function\&.  Parameter (variable) expansions beginning with $ are allowed
to remain intact without escaping the $, to allow the argument to contain
references to variables to be expanded by the shell\&.

.fi
.PP
 
.PP
Definition at line \fB267\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.EncodePOSIXShellList ( list)"

.PP
.nf
Encodes |list| suitably for consumption by POSIX shells\&.

Returns EncodePOSIXShellArgument for each item in list, and joins them
together using the space character as an argument separator\&.

.fi
.PP
 
.PP
Definition at line \fB290\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.EnsureDirExists ( path)"

.PP
.nf
Make sure the directory for |path| exists\&.
.fi
.PP
 
.PP
Definition at line \fB425\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.ExceptionAppend ( e,  msg)"

.PP
.nf
Append a message to the given exception's message\&.
.fi
.PP
 
.PP
Definition at line \fB40\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.FindQualifiedTargets ( target,  qualified_list)"

.PP
.nf
Given a list of qualified targets, return the qualified targets for the
specified |target|\&.

.fi
.PP
 
.PP
Definition at line \fB50\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.FixIfRelativePath ( path,  relative_to)"

.PP
Definition at line \fB197\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.GetEnvironFallback ( var_list,  default)"

.PP
.nf
Look up a key in the environment, with fallback to secondary keys
and finally falling back to a default value\&.
.fi
.PP
 
.PP
Definition at line \fB117\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.GetFlavor ( params)"

.PP
.nf
Returns |params\&.flavor| if it's set, the system's default flavor else\&.
.fi
.PP
 
.PP
Definition at line \fB433\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.InvertRelativePath ( path,  toplevel_dir = \fRNone\fP)"

.PP
.nf
Given a path like foo/bar that is relative to toplevel_dir, return
the inverse relative path back to the toplevel_dir\&.

E\&.g\&. os\&.path\&.normpath(os\&.path\&.join(path, InvertRelativePath(path)))
should always produce the empty string, unless the path contains symlinks\&.

.fi
.PP
 
.PP
Definition at line \fB184\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.IsCygwin ()"

.PP
Definition at line \fB646\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.ParseQualifiedTarget ( target)"

.PP
Definition at line \fB58\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.QualifiedTarget ( build_file,  target,  toolset)"

.PP
Definition at line \fB126\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.RelativePath ( path,  relative_to,  follow_path_symlink = \fRTrue\fP)"

.PP
Definition at line \fB137\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.ResolveTarget ( build_file,  target,  toolset)"

.PP
Definition at line \fB77\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.TopologicallySorted ( graph,  get_edges)"

.PP
.nf
Topologically sort based on a user provided edge definition\&.

Args:
graph: A list of node names\&.
get_edges: A function mapping from node name to a hashable collection
       of node names which this node has outgoing edges to\&.
Returns:
A list containing all of the node in graph in topological order\&.
It is assumed that calling get_edges once for each node and caching is
cheaper than repeatedly calling get_edges\&.
Raises:
CycleError in the event of a cycle\&.
Example:
graph = {'a': '$(b) $(c)', 'b': 'hi', 'c': '$(b)'}
def GetEdges(node):
return re\&.findall(r'\\$\\(([^))]\\)', graph[node])
print TopologicallySorted(graph\&.keys(), GetEdges)
==>
['a', 'c', b']

.fi
.PP
 
.PP
Definition at line \fB589\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.uniquer ( seq,  idfun = \fRlambda x: x\fP)"

.PP
Definition at line \fB501\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.UnrelativePath ( path,  relative_to)"

.PP
Definition at line \fB204\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.WriteOnDiff ( filename)"

.PP
.nf
Write to a file only if the new contents differ\&.

Arguments:
filename: name of the file to potentially write to\&.
Returns:
A file like object which will write to temporary file and only overwrite
the target if it differs (on close)\&.

.fi
.PP
 
.PP
Definition at line \fB336\fP of file \fBcommon\&.py\fP\&.
.SH "Variable Documentation"
.PP 
.SS "gyp\&.common\&._escape = re\&.compile(r'(['\\\\`])')\fR [protected]\fP"

.PP
Definition at line \fB264\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&._quote = re\&.compile('[\\t\\n #$%&'()*;<=>?[{|}~]|^$')\fR [protected]\fP"

.PP
Definition at line \fB238\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.tmp_file"

.PP
Definition at line \fB366\fP of file \fBcommon\&.py\fP\&.
.SS "gyp\&.common\&.tmp_path"

.PP
Definition at line \fB360\fP of file \fBcommon\&.py\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
