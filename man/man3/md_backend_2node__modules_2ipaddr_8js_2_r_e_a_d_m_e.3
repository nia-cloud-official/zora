.TH "md_backend_2node__modules_2ipaddr_8js_2_r_e_a_d_m_e" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
md_backend_2node__modules_2ipaddr_8js_2_r_e_a_d_m_e \- ipaddr\&.js â€” an IPv6 and IPv4 address manipulation library \fR\fP 
.PP
 ipaddr\&.js is a small (1\&.9K minified and gzipped) library for manipulating IP addresses in JavaScript environments\&. It runs on both CommonJS runtimes (e\&.g\&. \fRnodejs\fP) and in a web browser\&.
.PP
ipaddr\&.js allows you to verify and parse string representation of an IP address, match it against a CIDR range or range list, determine if it falls into some reserved ranges (examples include loopback and private ranges), and convert between IPv4 and IPv4-mapped IPv6 addresses\&.
.SH "Installation"
.PP
\fRnpm install ipaddr\&.js\fP
.PP
or
.PP
\fRbower install ipaddr\&.js\fP
.SH "API"
.PP
ipaddr\&.js defines one object in the global scope: \fRipaddr\fP\&. In CommonJS, it is exported from the module:
.PP
.PP
.nf
var ipaddr = require('ipaddr\&.js');
.fi
.PP
.PP
The API consists of several global methods and two classes: ipaddr\&.IPv6 and ipaddr\&.IPv4\&.
.SS "Global methods"
There are three global methods defined: \fRipaddr\&.isValid\fP, \fRipaddr\&.parse\fP and \fRipaddr\&.process\fP\&. All of them receive a string as a single parameter\&.
.PP
The \fRipaddr\&.isValid\fP method returns \fRtrue\fP if the address is a valid IPv4 or IPv6 address, and \fRfalse\fP otherwise\&. It does not throw any exceptions\&.
.PP
The \fRipaddr\&.parse\fP method returns an object representing the IP address, or throws an \fRError\fP if the passed string is not a valid representation of an IP address\&.
.PP
The \fRipaddr\&.process\fP method works just like the \fRipaddr\&.parse\fP one, but it automatically converts IPv4-mapped IPv6 addresses to their IPv4 counterparts before returning\&. It is useful when you have a Node\&.js instance listening on an IPv6 socket, and the \fRnet\&.ivp6\&.bindv6only\fP sysctl parameter (or its equivalent on non-Linux OS) is set to 0\&. In this case, you can accept IPv4 connections on your IPv6-only socket, but the remote address will be mangled\&. Use \fRipaddr\&.process\fP method to automatically demangle it\&.
.SS "Object representation"
Parsing methods return an object which descends from \fRipaddr\&.IPv6\fP or \fRipaddr\&.IPv4\fP\&. These objects share some properties, but most of them differ\&.
.SS "Shared properties"
One can determine the type of address by calling \fRaddr\&.kind()\fP\&. It will return either \fR'ipv6'\fP or \fR'ipv4'\fP\&.
.PP
An address can be converted back to its string representation with \fRaddr\&.toString()\fP\&. Note that this method:
.IP "\(bu" 2
does not return the original string used to create the object (in fact, there is no way of getting that string)
.IP "\(bu" 2
returns a compact representation (when it is applicable)
.PP
.PP
A \fRmatch(range, bits)\fP method can be used to check if the address falls into a certain CIDR range\&. Note that an address can be (obviously) matched only against an address of the same type\&.
.PP
For example:
.PP
.PP
.nf
var addr = ipaddr\&.parse("2001:db8:1234::1");
var range = ipaddr\&.parse("2001:db8::");

addr\&.match(range, 32); // => true
.fi
.PP
.PP
Alternatively, \fRmatch\fP can also be called as \fRmatch([range, bits])\fP\&. In this way, it can be used together with the \fRparseCIDR(string)\fP method, which parses an IP address together with a CIDR range\&.
.PP
For example:
.PP
.PP
.nf
var addr = ipaddr\&.parse("2001:db8:1234::1");

addr\&.match(ipaddr\&.parseCIDR("2001:db8::/32")); // => true
.fi
.PP
.PP
A \fRrange()\fP method returns one of predefined names for several special ranges defined by IP protocols\&. The exact names (and their respective CIDR ranges) can be looked up in the source: \fRIPv6 ranges\fP and \fRIPv4 ranges\fP\&. Some common ones include \fR'unicast'\fP (the default one) and \fR'reserved'\fP\&.
.PP
You can match against your own range list by using \fRipaddr\&.subnetMatch(address, rangeList, defaultName)\fP method\&. It can work with a mix of IPv6 or IPv4 addresses, and accepts a name-to-subnet map as the range list\&. For example:
.PP
.PP
.nf
var rangeList = {
  documentationOnly: [ ipaddr\&.parse('2001:db8::'), 32 ],
  tunnelProviders: [
    [ ipaddr\&.parse('2001:470::'), 32 ], // he\&.net
    [ ipaddr\&.parse('2001:5c0::'), 32 ]  // freenet6
  ]
};
ipaddr\&.subnetMatch(ipaddr\&.parse('2001:470:8:66::1'), rangeList, 'unknown'); // => "tunnelProviders"
.fi
.PP
.PP
The addresses can be converted to their byte representation with \fRtoByteArray()\fP\&. (Actually, JavaScript mostly does not know about byte buffers\&. They are emulated with arrays of numbers, each in range of 0\&.\&.255\&.)
.PP
.PP
.nf
var bytes = ipaddr\&.parse('2a00:1450:8007::68')\&.toByteArray(); // ipv6\&.google\&.com
bytes // => [42, 0x00, 0x14, 0x50, 0x80, 0x07, 0x00, <zeroes\&.\&.\&.>, 0x00, 0x68 ]
.fi
.PP
.PP
The \fRipaddr\&.IPv4\fP and \fRipaddr\&.IPv6\fP objects have some methods defined, too\&. All of them have the same interface for both protocols, and are similar to global methods\&.
.PP
\fRipaddr\&.IPvX\&.isValid(string)\fP can be used to check if the string is a valid address for particular protocol, and \fRipaddr\&.IPvX\&.parse(string)\fP is the error-throwing parser\&.
.PP
\fRipaddr\&.IPvX\&.isValid(string)\fP uses the same format for parsing as the POSIX \fRinet_ntoa\fP function, which accepts unusual formats like \fR0xc0\&.168\&.1\&.1\fP or \fR0x10000000\fP\&. The function \fRipaddr\&.IPv4\&.isValidFourPartDecimal(string)\fP validates the IPv4 address and also ensures that it is written in four-part decimal format\&.
.SS "IPv6 properties"
Sometimes you will want to convert IPv6 not to a compact string representation (with the \fR::\fP substitution); the \fRtoNormalizedString()\fP method will return an address where all zeroes are explicit\&.
.PP
For example:
.PP
.PP
.nf
var addr = ipaddr\&.parse("2001:0db8::0001");
addr\&.toString(); // => "2001:db8::1"
addr\&.toNormalizedString(); // => "2001:db8:0:0:0:0:0:1"
.fi
.PP
.PP
The \fRisIPv4MappedAddress()\fP method will return \fRtrue\fP if this address is an IPv4-mapped one, and \fRtoIPv4Address()\fP will return an IPv4 object address\&.
.PP
To access the underlying binary representation of the address, use \fRaddr\&.parts\fP\&.
.PP
.PP
.nf
var addr = ipaddr\&.parse("2001:db8:10::1234:DEAD");
addr\&.parts // => [0x2001, 0xdb8, 0x10, 0, 0, 0, 0x1234, 0xdead]
.fi
.PP
.PP
A IPv6 zone index can be accessed via \fRaddr\&.zoneId\fP:
.PP
.PP
.nf
var addr = ipaddr\&.parse("2001:db8::%eth0");
addr\&.zoneId // => 'eth0'
.fi
.PP
.SS "IPv4 properties"
\fRtoIPv4MappedAddress()\fP will return a corresponding IPv4-mapped IPv6 address\&.
.PP
To access the underlying representation of the address, use \fRaddr\&.octets\fP\&.
.PP
.PP
.nf
var addr = ipaddr\&.parse("192\&.168\&.1\&.1");
addr\&.octets // => [192, 168, 1, 1]
.fi
.PP
.PP
\fRprefixLengthFromSubnetMask()\fP will return a CIDR prefix length for a valid IPv4 netmask or null if the netmask is not valid\&.
.PP
.PP
.nf
ipaddr\&.IPv4\&.parse('255\&.255\&.255\&.240')\&.prefixLengthFromSubnetMask() == 28
ipaddr\&.IPv4\&.parse('255\&.192\&.164\&.0')\&.prefixLengthFromSubnetMask()  == null
.fi
.PP
.PP
\fRsubnetMaskFromPrefixLength()\fP will return an IPv4 netmask for a valid CIDR prefix length\&.
.PP
.PP
.nf
ipaddr\&.IPv4\&.subnetMaskFromPrefixLength(24) == "255\&.255\&.255\&.0"
ipaddr\&.IPv4\&.subnetMaskFromPrefixLength(29) == "255\&.255\&.255\&.248"
.fi
.PP
.PP
\fRbroadcastAddressFromCIDR()\fP will return the broadcast address for a given IPv4 interface and netmask in CIDR notation\&. 
.PP
.nf
ipaddr\&.IPv4\&.broadcastAddressFromCIDR("172\&.0\&.0\&.1/24") == "172\&.0\&.0\&.255"

.fi
.PP
 \fRnetworkAddressFromCIDR()\fP will return the network address for a given IPv4 interface and netmask in CIDR notation\&. 
.PP
.nf
ipaddr\&.IPv4\&.networkAddressFromCIDR("172\&.0\&.0\&.1/24") == "172\&.0\&.0\&.0"

.fi
.PP
.SS "Conversion"
IPv4 and IPv6 can be converted bidirectionally to and from network byte order (MSB) byte arrays\&.
.PP
The \fRfromByteArray()\fP method will take an array and create an appropriate IPv4 or IPv6 object if the input satisfies the requirements\&. For IPv4 it has to be an array of four 8-bit values, while for IPv6 it has to be an array of sixteen 8-bit values\&.
.PP
For example: 
.PP
.nf
var addr = ipaddr\&.fromByteArray([0x7f, 0, 0, 1]);
addr\&.toString(); // => "127\&.0\&.0\&.1"

.fi
.PP
.PP
or
.PP
.PP
.nf
var addr = ipaddr\&.fromByteArray([0x20, 1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1])
addr\&.toString(); // => "2001:db8::1"
.fi
.PP
.PP
Both objects also offer a \fRtoByteArray()\fP method, which returns an array in network byte order (MSB)\&.
.PP
For example: 
.PP
.nf
var addr = ipaddr\&.parse("127\&.0\&.0\&.1");
addr\&.toByteArray(); // => [0x7f, 0, 0, 1]

.fi
.PP
.PP
or
.PP
.PP
.nf
var addr = ipaddr\&.parse("2001:db8::1");
addr\&.toByteArray(); // => [0x20, 1, 0xd, 0xb8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
.fi
.PP
 
