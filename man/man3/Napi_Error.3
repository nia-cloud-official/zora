.TH "Napi::Error" 3 "My Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
Napi::Error
.SH SYNOPSIS
.br
.PP
.PP
\fR#include <napi\&.h>\fP
.PP
Inherits \fBNapi::ObjectReference\fP\&.
.PP
Inherited by \fBNapi::RangeError\fP, and \fBNapi::TypeError\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBError\fP ()"
.br
.ti -1c
.RI "\fBError\fP (napi_env env, napi_value value)"
.br
.ti -1c
.RI "\fBError\fP (\fBError\fP &&other)"
.br
.ti -1c
.RI "\fBError\fP & \fBoperator=\fP (\fBError\fP &&other)"
.br
.ti -1c
.RI "\fBError\fP (const \fBError\fP &)"
.br
.ti -1c
.RI "\fBError\fP & \fBoperator=\fP (const \fBError\fP &)"
.br
.ti -1c
.RI "const std::string & \fBMessage\fP () const \fBNAPI_NOEXCEPT\fP"
.br
.ti -1c
.RI "void \fBThrowAsJavaScriptException\fP () const"
.br
.ti -1c
.RI "\fBObject\fP \fBValue\fP () const"
.br
.in -1c

Public Member Functions inherited from \fBNapi::ObjectReference\fP
.in +1c
.ti -1c
.RI "\fBObjectReference\fP ()"
.br
.ti -1c
.RI "\fBObjectReference\fP (napi_env env, napi_ref ref)"
.br
.ti -1c
.RI "\fBObjectReference\fP (\fBReference\fP< \fBObject\fP > &&other)"
.br
.ti -1c
.RI "\fBObjectReference\fP & \fBoperator=\fP (\fBReference\fP< \fBObject\fP > &&other)"
.br
.ti -1c
.RI "\fBObjectReference\fP (\fBObjectReference\fP &&other)"
.br
.ti -1c
.RI "\fBObjectReference\fP & \fBoperator=\fP (\fBObjectReference\fP &&other)"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< \fBNapi::Value\fP > \fBGet\fP (const char *utf8name) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< \fBNapi::Value\fP > \fBGet\fP (const std::string &utf8name) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (const char *utf8name, napi_value value) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (const char *utf8name, \fBNapi::Value\fP value) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (const char *utf8name, const char *utf8value) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (const char *utf8name, bool boolValue) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (const char *utf8name, double numberValue) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (const std::string &utf8name, napi_value value) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (const std::string &utf8name, \fBNapi::Value\fP value) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (const std::string &utf8name, std::string &utf8value) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (const std::string &utf8name, bool boolValue) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (const std::string &utf8name, double numberValue) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< \fBNapi::Value\fP > \fBGet\fP (uint32_t index) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (uint32_t index, const napi_value value) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (uint32_t index, const \fBNapi::Value\fP value) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (uint32_t index, const char *utf8value) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (uint32_t index, const std::string &utf8value) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (uint32_t index, bool boolValue) const"
.br
.ti -1c
.RI "\fBMaybeOrValue\fP< bool > \fBSet\fP (uint32_t index, double numberValue) const"
.br
.in -1c

Public Member Functions inherited from \fBNapi::Reference< Object >\fP
.in +1c
.ti -1c
.RI "\fBReference\fP ()"
.br
.ti -1c
.RI "\fBReference\fP (napi_env env, napi_ref ref)"
.br
.ti -1c
.RI "\fBReference\fP (\fBReference\fP< \fBObject\fP > &&other)"
.br
.ti -1c
.RI "\fB~Reference\fP ()"
.br
.ti -1c
.RI "\fBReference\fP< \fBObject\fP > & \fBoperator=\fP (\fBReference\fP< \fBObject\fP > &&other)"
.br
.ti -1c
.RI "\fBoperator napi_ref\fP () const"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBReference\fP< \fBObject\fP > &other) const"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBReference\fP< \fBObject\fP > &other) const"
.br
.ti -1c
.RI "\fBNapi::Env\fP \fBEnv\fP () const"
.br
.ti -1c
.RI "bool \fBIsEmpty\fP () const"
.br
.ti -1c
.RI "\fBObject\fP \fBValue\fP () const"
.br
.ti -1c
.RI "uint32_t \fBRef\fP () const"
.br
.ti -1c
.RI "uint32_t \fBUnref\fP () const"
.br
.ti -1c
.RI "void \fBReset\fP ()"
.br
.ti -1c
.RI "void \fBReset\fP (const \fBObject\fP &value, uint32_t refcount=0)"
.br
.ti -1c
.RI "void \fBSuppressDestruct\fP ()"
.br
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBError\fP \fBNew\fP (napi_env env)"
.br
.ti -1c
.RI "static \fBError\fP \fBNew\fP (napi_env env, const char *message)"
.br
.ti -1c
.RI "static \fBError\fP \fBNew\fP (napi_env env, const std::string &message)"
.br
.ti -1c
.RI "static NAPI_NO_RETURN void \fBFatal\fP (const char *location, const char *message)"
.br
.in -1c

Static Public Member Functions inherited from \fBNapi::Reference< Object >\fP
.in +1c
.ti -1c
.RI "static \fBReference\fP< \fBObject\fP > \fBNew\fP (const \fBObject\fP &value, uint32_t initialRefcount=0)"
.br
.in -1c
.SS "Protected Types"

.in +1c
.ti -1c
.RI "using \fBcreate_error_fn\fP"
.br
.RI "!cond INTERNAL "
.in -1c
.SS "Static Protected Member Functions"

.in +1c
.ti -1c
.RI "template<typename TError > static TError \fBNew\fP (napi_env env, const char *message, size_t length, \fBcreate_error_fn\fP create_error)"
.br
.in -1c
.SS "Additional Inherited Members"


Protected Member Functions inherited from \fBNapi::ObjectReference\fP
.in +1c
.ti -1c
.RI "\fBObjectReference\fP (const \fBObjectReference\fP &)"
.br
.in -1c

Protected Member Functions inherited from \fBNapi::Reference< Object >\fP
.in +1c
.ti -1c
.RI "\fBReference\fP (const \fBReference\fP< \fBObject\fP > &)"
.br
.in -1c

Protected Attributes inherited from \fBNapi::Reference< Object >\fP
.in +1c
.ti -1c
.RI "napi_env \fB_env\fP"
.br
.RI "!cond INTERNAL "
.ti -1c
.RI "napi_ref \fB_ref\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
A persistent reference to a JavaScript error object\&. Use of this class depends somewhat on whether C++ exceptions are enabled at compile time\&.
.SS "Handling Errors With C++ Exceptions"
If C++ exceptions are enabled, then the \fR\fBError\fP\fP class extends \fRstd::exception\fP and enables integrated error-handling for C++ exceptions and JavaScript exceptions\&.
.PP
If a Node-API call fails without executing any JavaScript code (for example due to an invalid argument), then the Node-API wrapper automatically converts and throws the error as a C++ exception of type \fR\fBNapi::Error\fP\fP\&. Or if a JavaScript function called by C++ code via Node-API throws a JavaScript exception, then the Node-API wrapper automatically converts and throws it as a C++ exception of type \fR\fBNapi::Error\fP\fP\&.
.PP
If a C++ exception of type \fR\fBNapi::Error\fP\fP escapes from a Node-API C++ callback, then the Node-API wrapper automatically converts and throws it as a JavaScript exception\&. Therefore, catching a C++ exception of type \fR\fBNapi::Error\fP\fP prevents a JavaScript exception from being thrown\&.
.SS "Example 1A - Throwing a C++ exception:"
.PP
.nf
Napi::Env env = \&.\&.\&.
throw Napi::Error::New(env, 'Example exception');
.fi
.PP
 Following C++ statements will not be executed\&. The exception will bubble up as a C++ exception of type \fR\fBNapi::Error\fP\fP, until it is either caught while still in C++, or else automatically propataged as a JavaScript exception when the callback returns to JavaScript\&.
.SS "Example 2A - Propagating a Node-API C++ exception:"
.PP
.nf
Napi::Function jsFunctionThatThrows = someObj\&.As<Napi::Function>();
Napi::Value result = jsFunctionThatThrows({ arg1, arg2 });
.fi
.PP
 Following C++ statements will not be executed\&. The exception will bubble up as a C++ exception of type \fR\fBNapi::Error\fP\fP, until it is either caught while still in C++, or else automatically propagated as a JavaScript exception when the callback returns to JavaScript\&.
.SS "Example 3A - Handling a Node-API C++ exception:"
.PP
.nf
Napi::Function jsFunctionThatThrows = someObj\&.As<Napi::Function>();
Napi::Value result;
try {
   result = jsFunctionThatThrows({ arg1, arg2 });
} catch (const Napi::Error& e) {
  cerr << 'Caught JavaScript exception: ' + e\&.what();
}
.fi
.PP
 Since the exception was caught here, it will not be propagated as a JavaScript exception\&.
.SS "Handling Errors Without C++ Exceptions"
If C++ exceptions are disabled (by defining \fRNAPI_DISABLE_CPP_EXCEPTIONS\fP) then this class does not extend \fRstd::exception\fP, and APIs in the \fR\fBNapi\fP\fP namespace do not throw C++ exceptions when they fail\&. Instead, they raise \fIpending\fP JavaScript exceptions and return \fIempty\fP \fR\fBValue\fP\fPs\&. Calling code should check \fR\fBValue::IsEmpty()\fP\fP before attempting to use a returned value, and may use methods on the \fR\fBEnv\fP\fP class to check for, get, and clear a pending JavaScript exception\&. If the pending exception is not cleared, it will be thrown when the native callback returns to JavaScript\&.
.SS "Example 1B - Throwing a JS exception"
.PP
.nf
Napi::Env env = \&.\&.\&.
Napi::Error::New(env, 'Example
exception')\&.ThrowAsJavaScriptException(); return;
.fi
.PP
 After throwing a JS exception, the code should generally return immediately from the native callback, after performing any necessary cleanup\&.
.SS "Example 2B - Propagating a Node-API JS exception:"
.PP
.nf
Napi::Function jsFunctionThatThrows = someObj\&.As<Napi::Function>();
Napi::Value result = jsFunctionThatThrows({ arg1, arg2 });
if (result\&.IsEmpty()) return;
.fi
.PP
 An empty value result from a Node-API call indicates an error occurred, and a JavaScript exception is pending\&. To let the exception propagate, the code should generally return immediately from the native callback, after performing any necessary cleanup\&.
.SS "Example 3B - Handling a Node-API JS exception:"
.PP
.nf
Napi::Function jsFunctionThatThrows = someObj\&.As<Napi::Function>();
Napi::Value result = jsFunctionThatThrows({ arg1, arg2 });
if (result\&.IsEmpty()) {
  Napi::Error e = env\&.GetAndClearPendingException();
  cerr << 'Caught JavaScript exception: ' + e\&.Message();
}
.fi
.PP
 Since the exception was cleared here, it will not be propagated as a JavaScript exception after the native callback returns\&. 
.PP
Definition at line \fB1787\fP of file \fBnapi\&.h\fP\&.
.SH "Member Typedef Documentation"
.PP 
.SS "using \fBNapi::Error::create_error_fn\fP\fR [protected]\fP"
\fBInitial value:\fP
.nf
 napi_status (*)(napi_env envb,
                                          napi_value code,
                                          napi_value msg,
                                          napi_value* result)
.PP
.fi

.PP
!cond INTERNAL 
.PP
Definition at line \fB1820\fP of file \fBnapi\&.h\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "Napi::Error::Error ()\fR [inline]\fP"

.PP
Definition at line \fB2894\fP of file \fBnapi\-inl\&.h\fP\&.
.SS "Napi::Error::Error (napi_env env, napi_value value)\fR [inline]\fP"

.PP
Definition at line \fB2896\fP of file \fBnapi\-inl\&.h\fP\&.
.SS "Napi::Error::Error (\fBError\fP && other)\fR [inline]\fP"

.PP
Definition at line \fB2991\fP of file \fBnapi\-inl\&.h\fP\&.
.SS "Napi::Error::Error (const \fBError\fP & other)\fR [inline]\fP"

.PP
Definition at line \fB2998\fP of file \fBnapi\-inl\&.h\fP\&.
.SH "Member Function Documentation"
.PP 
.SS "NAPI_NO_RETURN void Napi::Error::Fatal (const char * location, const char * message)\fR [inline]\fP, \fR [static]\fP"

.PP
Definition at line \fB2889\fP of file \fBnapi\-inl\&.h\fP\&.
.SS "const std::string & Napi::Error::Message () const\fR [inline]\fP"

.PP
Definition at line \fB3015\fP of file \fBnapi\-inl\&.h\fP\&.
.SS "\fBError\fP Napi::Error::New (napi_env env)\fR [inline]\fP, \fR [static]\fP"

.PP
Definition at line \fB2822\fP of file \fBnapi\-inl\&.h\fP\&.
.SS "\fBError\fP Napi::Error::New (napi_env env, const char * message)\fR [inline]\fP, \fR [static]\fP"

.PP
Definition at line \fB2879\fP of file \fBnapi\-inl\&.h\fP\&.
.SS "template<typename TError > TError Napi::Error::New (napi_env env, const char * message, size_t length, \fBcreate_error_fn\fP create_error)\fR [inline]\fP, \fR [static]\fP, \fR [protected]\fP"

.PP
Definition at line \fB3099\fP of file \fBnapi\-inl\&.h\fP\&.
.SS "\fBError\fP Napi::Error::New (napi_env env, const std::string & message)\fR [inline]\fP, \fR [static]\fP"

.PP
Definition at line \fB2884\fP of file \fBnapi\-inl\&.h\fP\&.
.SS "\fBError\fP & Napi::Error::operator= (const \fBError\fP & other)\fR [inline]\fP"

.PP
Definition at line \fB3000\fP of file \fBnapi\-inl\&.h\fP\&.
.SS "\fBError\fP & Napi::Error::operator= (\fBError\fP && other)\fR [inline]\fP"

.PP
Definition at line \fB2993\fP of file \fBnapi\-inl\&.h\fP\&.
.SS "void Napi::Error::ThrowAsJavaScriptException () const\fR [inline]\fP"

.PP
Definition at line \fB3039\fP of file \fBnapi\-inl\&.h\fP\&.
.SS "\fBObject\fP Napi::Error::Value () const\fR [inline]\fP"

.PP
Definition at line \fB2951\fP of file \fBnapi\-inl\&.h\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for My Project from the source code\&.
